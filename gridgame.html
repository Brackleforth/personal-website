<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid-Based Browser Game - Static Levels with Enemies</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #000; overflow: hidden; position: relative; }
        canvas { display: block; background-color: #222; }
        .controls { position: absolute; bottom: 10px; right: 10px; display: grid; grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(2, 70px); gap: 5px; z-index: 10; }
        .toggle-btn, .reset-btn { position: absolute; bottom: 10px; left: 10px; width: 100px; height: 60px; background-color: #555; color: #fff; border: 2px solid #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 18px; touch-action: manipulation; user-select: none; cursor: pointer; z-index: 10; }
        .reset-btn { bottom: 80px; }
        .toggle-btn:active, .reset-btn:active { background-color: #777; }
        .control-btn { background-color: rgba(85, 85, 85, 0.7); color: #fff; border: 2px solid #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 28px; touch-action: manipulation; user-select: none; cursor: pointer; width: 70px; height: 70px; }
        .control-btn:active { background-color: rgba(119, 119, 119, 0.7); }
        .empty { background: none; border: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <div class="empty"></div>
        <div class="control-btn" id="up-btn">↑</div>
        <div class="empty"></div>
        <div class="control-btn" id="left-btn">←</div>
        <div class="control-btn" id="down-btn">↓</div>
        <div class="control-btn" id="right-btn">→</div>
        <div class="empty"></div>
    </div>
    <div class="toggle-btn" id="toggle-btn">Jump1</div>
    <div class="reset-btn" id="reset-btn">Reset</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const virtualWidth = 1600;
    const virtualHeight = 900;
    let scale = 1;

    const gridWidth = 16;
    const gridHeight = 8;
    const cellWidth = virtualWidth / gridWidth;
    const cellHeight = (virtualHeight * (gridHeight / 9)) / gridHeight;
    const statusBarHeight = virtualHeight / 9;

    let currentLevel = 1;
    let levelName = "Level 1 - Temple";
    let hasWon = false;

    let isInputActive = false;
    let movementMode = 'jump1';
    let isPlayerDead = false;
    let movement_lock = false;
    let grid = [];
    let can_be_killed = 1; // Initialize can_be_killed to 1 (vulnerable)
    let moveCount = 0; // Track number of player moves

    let slipping = false;
    let slipDir = { dx: 0, dy: 0 };

    let totalFloorTiles = 0;

    function draw() {
    ctx.save();
    ctx.scale(scale, scale);
    ctx.clearRect(0, 0, virtualWidth, virtualHeight);

    const claimedTiles = grid.filter(cell => cell.isClaimed || cell.state === 'player').length;

    // Check for win condition (for cases like enemy movements or slipping)
    hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed || cell.state === 'player');

    ctx.fillStyle = '#F5F5F5';
    ctx.fillRect(0, 0, virtualWidth, statusBarHeight);
    ctx.fillStyle = '#666666';
    ctx.font = `${statusBarHeight * 0.5}px Arial`;
    ctx.textBaseline = 'middle';

    // Draw level name on the left
    ctx.textAlign = 'left';
    ctx.fillText(levelName, 10, statusBarHeight / 2);

    // Draw movement mode, status, moves, and tile counters on the right
    ctx.textAlign = 'right';
    ctx.fillText(`${movementMode}${isPlayerDead ? ' - Dead' : hasWon ? ' - Won' : ''} - Moves: ${moveCount} - Claimed: ${claimedTiles}/${totalFloorTiles}`, virtualWidth - 10, statusBarHeight / 2);

    grid.forEach(cell => {
        if (cell.state === 'floor') ctx.fillStyle = '#8B8B83';
        else if (cell.state === 'claimed') ctx.fillStyle = '#D3D3D3';
        else if (cell.state === 'wall') ctx.fillStyle = '#5C5C5A';
        else if (cell.state === 'pit') ctx.fillStyle = '#000000';
        else if (cell.state === 'player') ctx.fillStyle = isPlayerDead ? '#FF0000' : hasWon ? '#00FF00' : '#00f';
        else if (cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down') ctx.fillStyle = '#00FF00';
        ctx.fillRect(cell.x * cellWidth, statusBarHeight + cell.y * cellHeight, cellWidth, cellHeight);

        // Superimpose direction indicators for enemies
        if (cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down') {
            ctx.fillStyle = '#FFFFFF';
            ctx.font = `${cellHeight * 0.8}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            let symbol;
            switch (cell.state) {
                case 'enemy-right': symbol = '>'; break;
                case 'enemy-left': symbol = '<'; break;
                case 'enemy-up': symbol = '^'; break;
                case 'enemy-down': symbol = 'v'; break;
            }
            ctx.fillText(symbol, (cell.x + 0.5) * cellWidth, statusBarHeight + (cell.y + 0.5) * cellHeight);
        }
    });

    ctx.restore();
}

    function initializeGrid(level) {
        const levels = {
            1: {
                layout: [
                    "################",
                    "#..>....~~.....#",
                    "#..####..####..#",
                    "#..#..#..#..#..#",
                    "#..####..####..#",
                    "#....~~........#",
                    "#......P.....<.#",
                    "################"
                ],
                name: "Temple"
            },
            2: {
                layout: [
                    "################",
                    "#..#....~~...P.#",
                    "#..#....~~...<.#",
                    "#..###.####..#.#",
                    "#....#.#..#..#v#",
                    "#....#....#....#",
                    "#.>..##.###....#",
                    "################"
                ],
                name: "Cave"
            }
        };

        grid = [];
        const staticLevel = levels[level] || levels[1]; // Default to Level 1
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let char = staticLevel.layout[y][x];
                let state = 'floor';
                let isClaimed = false;
                if (char === '#') state = 'wall';
                else if (char === '.') state = 'floor';
                else if (char === 'P') state = 'player';
                else if (char === '~') state = 'pit';
                else if (char === '>') state = 'enemy-right';
                else if (char === '<') state = 'enemy-left';
                else if (char === '^') state = 'enemy-up';
                else if (char === 'v') state = 'enemy-down';
                grid.push({ x, y, state, isClaimed });
            }
        }
        totalFloorTiles = grid.filter(cell => cell.state !== 'wall' && cell.state !== 'pit').length;
        levelName = `Level ${level} - ${staticLevel.name}`;
        can_be_killed = 1; // Reset can_be_killed on level initialization
        moveCount = 0; // Reset move count
    }

    function resizeCanvas() {
        const aspect = virtualWidth / virtualHeight;
        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width / height > aspect) {
            canvas.height = height;
            canvas.width = height * aspect;
        } else {
            canvas.width = width;
            canvas.height = width / aspect;
        }

        scale = canvas.width / virtualWidth;
        draw();
    }

    function findPlayer() {
        return grid.find(cell => cell.state === 'player');
    }

    function attemptMove(dx, dy, claimStart = true) {
        const player = findPlayer();
        if (!player) return false;
        const newX = player.x + dx;
        const newY = player.y + dy;
        if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) return false;
        const target = grid.find(c => c.x === newX && c.y === newY);

        if (target.state === 'wall') return false;

        if (claimStart) {
            player.isClaimed = true; // Mark permanently
            player.state = 'claimed';
        }

        if (target.state === 'pit') {
            target.state = 'player';
            isPlayerDead = true;
            draw();
            return false;
        } else if (target.state.startsWith('enemy')) {
            return 'enemy';  // Defer placement for enemy targets
        } else if (target.isClaimed) { // Use isClaimed flag
            target.state = 'player';
            draw();
            return 'slip';
        } else {
            target.state = 'player';
            draw();
            return true;
        }
    }

    function moveEnemies() {
    const enemies = grid.filter(cell => cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down');
    const enemyUpdates = [];
    const swaps = new Map(); // Track swaps (enemy A to B's position, B to A's)

    // Step 1: Plan moves and detect swaps
    enemies.forEach(enemy => {
        const currentState = enemy.state;
        let dx = 0, dy = 0;
        let newState = currentState;
        let moveTo = null;

        // Set movement direction
        if (currentState === 'enemy-right') dx = 1;
        else if (currentState === 'enemy-left') dx = -1;
        else if (currentState === 'enemy-up') dy = -1;
        else if (currentState === 'enemy-down') dy = 1;

        let nextX = enemy.x + dx;
        let nextY = enemy.y + dy;

        // Check if move is valid
        if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
            const nextCell = grid.find(c => c.x === nextX && c.y === nextY);
            if (nextCell.state !== 'wall' && nextCell.state !== 'pit') {
                // Check for potential swap
                const targetEnemy = enemies.find(e => e.x === nextX && e.y === nextY);
                if (targetEnemy) {
                    let targetDx = 0, targetDy = 0;
                    if (targetEnemy.state === 'enemy-right') targetDx = 1;
                    else if (targetEnemy.state === 'enemy-left') targetDx = -1;
                    else if (targetEnemy.state === 'enemy-up') targetDy = -1;
                    else if (targetEnemy.state === 'enemy-down') targetDy = 1;
                    if (targetEnemy.x + targetDx === enemy.x && targetEnemy.y + targetDy === enemy.y) {
                        // Swap detected
                        const key = `${Math.min(enemy.x, nextX)},${Math.min(enemy.y, nextY)}-${Math.max(enemy.x, nextX)},${Math.max(enemy.y, nextY)}`;
                        if (!swaps.has(key)) {
                            swaps.set(key, [
                                { enemy, target: { x: nextX, y: nextY }, newState: enemy.state },
                                { enemy: targetEnemy, target: { x: enemy.x, y: enemy.y }, newState: targetEnemy.state }
                            ]);
                        }
                    } else {
                        // Non-swap enemy collision: reverse direction
                        if (currentState === 'enemy-right') newState = 'enemy-left';
                        else if (currentState === 'enemy-left') newState = 'enemy-right';
                        else if (currentState === 'enemy-up') newState = 'enemy-down';
                        else if (currentState === 'enemy-down') newState = 'enemy-up';
                    }
                } else {
                    moveTo = { x: nextX, y: nextY };
                }
            } else {
                // Wall or pit: reverse direction
                if (currentState === 'enemy-right') newState = 'enemy-left';
                else if (currentState === 'enemy-left') newState = 'enemy-right';
                else if (currentState === 'enemy-up') newState = 'enemy-down';
                else if (currentState === 'enemy-down') newState = 'enemy-up';
            }
        } else {
            // Boundary: reverse direction
            if (currentState === 'enemy-right') newState = 'enemy-left';
            else if (currentState === 'enemy-left') newState = 'enemy-right';
            else if (currentState === 'enemy-up') newState = 'enemy-down';
            else if (currentState === 'enemy-down') newState = 'enemy-up';
        }

        enemyUpdates.push({ enemy, newState, moveTo });
    });

    // Step 2: Detect landing conflicts for non-swap moves
    const landingPositions = new Map();
    enemyUpdates.forEach((update, index) => {
        if (swaps.has(`${update.enemy.x},${update.enemy.y}-${update.moveTo?.x},${update.moveTo?.y}`)) {
            return; // Skip swap moves
        }
        if (update.moveTo) {
            const key = `${update.moveTo.x},${update.moveTo.y}`;
            if (!landingPositions.has(key)) landingPositions.set(key, []);
            landingPositions.get(key).push({ update, index });
        }
    });

    // Step 3: Reverse enemies in non-swap landing conflicts
    landingPositions.forEach((targeters, key) => {
        if (targeters.length > 1) {
            targeters.forEach(({ update }) => {
                const currentState = update.enemy.state;
                if (currentState === 'enemy-right') update.newState = 'enemy-left';
                else if (currentState === 'enemy-left') update.newState = 'enemy-right';
                else if (currentState === 'enemy-up') update.newState = 'enemy-down';
                else if (currentState === 'enemy-down') update.newState = 'enemy-up';
                update.moveTo = null;
            });
        }
    });

    // Step 4: Recheck moves for reversed enemies
    enemyUpdates.forEach((update, index) => {
        if (!update.moveTo && update.newState !== update.enemy.state && !swaps.has(`${update.enemy.x},${update.enemy.y}-*`)) {
            let dx = 0, dy = 0;
            if (update.newState === 'enemy-right') dx = 1;
            else if (update.newState === 'enemy-left') dx = -1;
            else if (update.newState === 'enemy-up') dy = -1;
            else if (update.newState === 'enemy-down') dy = 1;

            const nextX = update.enemy.x + dx;
            const nextY = update.enemy.y + dy;
            if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                const newCell = grid.find(c => c.x === nextX && c.y === nextY);
                const key = `${nextX},${nextY}`;
                const otherTargeters = landingPositions.get(key)?.filter(t => t.index !== index) || [];
                if (newCell.state !== 'wall' && newCell.state !== 'pit' && otherTargeters.length === 0 && !swaps.has(`*-${nextX},${nextY}`)) {
                    update.moveTo = { x: nextX, y: nextY };
                    landingPositions.set(key, [{ update, index }]);
                }
            }
        }
    });

    // Step 5: Apply moves (swaps first, then regular moves)
    swaps.forEach(swap => {
        // Store current states and clear original positions
        const swapUpdates = swap.map(({ enemy, target, newState }) => ({
            enemy,
            target,
            newState,
            isClaimed: enemy.isClaimed
        }));
        // Clear original positions
        swapUpdates.forEach(({ enemy, isClaimed }) => {
            enemy.state = isClaimed ? 'claimed' : 'floor';
        });
        // Apply new positions
        swapUpdates.forEach(({ enemy, target, newState }) => {
            const targetCell = grid.find(c => c.x === target.x && c.y === target.y);
            if (targetCell.state === 'player') {
                isPlayerDead = true;
                enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                targetCell.state = 'player';
            } else {
                targetCell.state = newState;
            }
        });
    });

    // Apply non-swap moves
    enemyUpdates.forEach(({ enemy, newState, moveTo }) => {
        const swapKey = [...swaps.keys()].find(key => key.includes(`${enemy.x},${enemy.y}`));
        if (swapKey) return;

        if (moveTo) {
            const targetCell = grid.find(c => c.x === moveTo.x && c.y === moveTo.y);
            if (targetCell.state === 'player') {
                isPlayerDead = true;
                enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                targetCell.state = 'player';
            } else {
                enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                targetCell.state = newState;
            }
        } else {
            enemy.state = newState;
        }
    });

    draw();
}

    function slipStep() {
        if (!slipping) return;

        const player = findPlayer();
        if (!player) return;  // Safety check

        if (isPlayerDead) {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
            draw();
            return;
        }

        const dx = slipDir.dx;
        const dy = slipDir.dy;
        const newX = player.x + dx;
        const newY = player.y + dy;
        const target = grid.find(c => c.x === newX && c.y === newY);

        let result = attemptMove(dx, dy);

        if (result === 'enemy') {
            moveEnemies();
            if (target.state.startsWith('enemy')) {
                target.state = 'player';
                isPlayerDead = true;
                result = false;
            } else {
                target.state = 'player';
                result = target.isClaimed ? 'slip' : true;
            }
            draw();  // Update visuals after deferred placement
        } else {
            if (result === false && !isPlayerDead) {
                slipping = false;
                movement_lock = false;
                can_be_killed = 1;
                return;
            }
            moveEnemies();
        }

        if (result === 'slip' && !isPlayerDead) {
            setTimeout(slipStep, 100);
        } else {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
        }
    }

    function movePlayer(dx, dy) {
    if (isPlayerDead || movement_lock || hasWon || !can_be_killed) { 
        isInputActive = false; 
        return; 
    }

    moveCount++; // Increment move count for any key-press

    movement_lock = true;
    can_be_killed = 0;

    const jumpDistance = movementMode === 'jump1' ? 1 : 2;
    const player = findPlayer();
    const oldX = player.x;
    const oldY = player.y;
    const newX = oldX + dx * jumpDistance;
    const newY = oldY + dy * jumpDistance;

    let validMove = true;
    if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) validMove = false;
    else {
        const intendedTarget = grid.find(c => c.x === newX && c.y === newY);
        if (intendedTarget.state === 'wall') validMove = false;
    }

    const playerOldCell = player;
    let playerTargetCell;
    let claimStart = validMove;
    if (!validMove) {
        playerTargetCell = playerOldCell;
        movement_lock = false;
        isInputActive = false;
        can_be_killed = 1;
        moveEnemies();
        draw();
        return;
    } else {
        playerTargetCell = grid.find(c => c.x === newX && c.y === newY);
    }

    if (claimStart) {
        playerOldCell.isClaimed = true;
        playerOldCell.state = 'claimed';
    }

    let result;
    let enemyThere = playerTargetCell.state.startsWith('enemy');

    if (playerTargetCell.state === 'pit') {
        playerTargetCell.state = 'player';
        isPlayerDead = true;
        result = false;
    } else if (!enemyThere) {
        playerTargetCell.state = 'player';
        if (playerTargetCell.isClaimed) {
            result = 'slip';
        } else {
            result = true;
        }
    }
    // Defer placement and death if enemyThere (handled after moveEnemies)

    // Check win condition after claiming a tile
    hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed);

    draw();
    moveEnemies();
    can_be_killed = 1;

    if (enemyThere) {
        if (playerTargetCell.state.startsWith('enemy')) {
            // Enemy didn't move away
            playerTargetCell.state = 'player';
            isPlayerDead = true;
            result = false;
            draw();  // Update visuals after deferred placement
        } else {
            // Enemy moved away successfully
            playerTargetCell.state = 'player';
            if (playerTargetCell.isClaimed) {
                result = 'slip';
            } else {
                result = true;
            }
            draw();  // Update visuals after deferred placement
        }
        // Recheck win condition after enemy movement
        hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed);
    }

    if (result === 'slip') {
        slipping = true;
        slipDir = { dx, dy };
        setTimeout(slipStep, 100);
    } else {
        movement_lock = false;
    }
    isInputActive = false;
}

    function toggleMovementMode() {
        if (isPlayerDead || slipping || hasWon || !can_be_killed) return;
        movementMode = movementMode === 'jump1' ? 'jump2' : 'jump1';
        document.getElementById('toggle-btn').textContent = movementMode === 'jump1' ? 'Jump1' : 'Jump2';
        draw();
    }

    function resetLevel() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        initializeGrid(currentLevel);
        moveCount = 0; // Reset move count
        draw();
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
    }

    function resetGame() {
        currentLevel = 1;
        resetLevel();
    }

    function changeLevel(direction) {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        currentLevel = direction === 'next' ? (currentLevel === 1 ? 2 : 1) : (currentLevel === 2 ? 1 : 1);
        initializeGrid(currentLevel);
        moveCount = 0; // Reset move count
        draw();
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
    }

    // Input events
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('keydown', (e) => {
        if (isInputActive || slipping || !can_be_killed) return;
        isInputActive = true;
        switch (e.key.toLowerCase()) {
            case 'arrowup': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, -1); break;
            case 'arrowdown': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, 1); break;
            case 'arrowleft': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(-1, 0); break;
            case 'arrowright': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(1, 0); break;
            case ' ': 
                if (hasWon) changeLevel('next');
                else if (isPlayerDead) resetLevel();
                else toggleMovementMode();
                break;
            case 'q': changeLevel('previous'); break;
            case 'w': changeLevel('next'); break;
        }
    });
    window.addEventListener('keyup', (e) => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            movement_lock = false;
        }
        isInputActive = false;
    });

    // On-screen buttons
    const buttons = { 'up-btn': [0, -1], 'down-btn': [0, 1], 'left-btn': [-1, 0], 'right-btn': [1, 0] };
    Object.keys(buttons).forEach(id => {
        const btn = document.getElementById(id);
        const [dx, dy] = buttons[id];
        function press(e) { e.preventDefault(); if (!isInputActive && !isPlayerDead && !movement_lock && !slipping && !hasWon && can_be_killed) { isInputActive = true; movePlayer(dx, dy); } }
        function release(e) { e.preventDefault(); isInputActive = false; movement_lock = false; }
        btn.addEventListener('mousedown', press); btn.addEventListener('mouseup', release);
        btn.addEventListener('touchstart', press); btn.addEventListener('touchend', release);
    });

    // Toggle button
    const toggleBtn = document.getElementById('toggle-btn');
    toggleBtn.addEventListener('mousedown', e => { e.preventDefault(); if (!isInputActive && !isPlayerDead && !slipping && !hasWon && can_be_killed) { isInputActive = true; toggleMovementMode(); } });
    toggleBtn.addEventListener('mouseup', e => { e.preventDefault(); isInputActive = false; });
    toggleBtn.addEventListener('touchstart', e => { e.preventDefault(); if (!isPlayerDead && !slipping && !hasWon && can_be_killed) { isInputActive = true; toggleMovementMode(); } });
    toggleBtn.addEventListener('touchend', e => { e.preventDefault(); isInputActive = false; });

    // Reset button
    const resetBtn = document.getElementById('reset-btn');
    function resetPress(e) { e.preventDefault(); if (!isInputActive) { isInputActive = true; resetLevel(); } }
    function resetRelease(e) { e.preventDefault(); isInputActive = false; }
    resetBtn.addEventListener('mousedown', resetPress); resetBtn.addEventListener('mouseup', resetRelease);
    resetBtn.addEventListener('touchstart', resetPress); resetBtn.addEventListener('touchend', resetRelease);

    // Init
    initializeGrid(currentLevel);
    resizeCanvas();
</script>
</body>
</html>