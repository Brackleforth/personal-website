<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid-Based Browser Game - Static Levels with Enemies</title>
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #000; overflow: hidden; position: relative; }
        canvas { display: block; background-color: #222; }
        .controls { position: absolute; bottom: 10px; right: 10px; display: grid; grid-template-columns: repeat(3, 70px); grid-template-rows: repeat(2, 70px); gap: 5px; z-index: 10; }
        .toggle-btn, .reset-btn { position: absolute; bottom: 10px; left: 10px; width: 100px; height: 60px; background-color: #555; color: #fff; border: 2px solid #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 18px; touch-action: manipulation; user-select: none; cursor: pointer; z-index: 10; }
        .reset-btn { bottom: 80px; }
        .toggle-btn:active, .reset-btn:active { background-color: #777; }
        .control-btn { background-color: rgba(85, 85, 85, 0.7); color: #fff; border: 2px solid #fff; border-radius: 10px; display: flex; justify-content: center; align-items: center; font-size: 28px; touch-action: manipulation; user-select: none; cursor: pointer; width: 70px; height: 70px; }
        .control-btn:active { background-color: rgba(119, 119, 119, 0.7); }
        .empty { background: none; border: none; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <div class="empty"></div>
        <div class="control-btn" id="up-btn">↑</div>
        <div class="empty"></div>
        <div class="control-btn" id="left-btn">←</div>
        <div class="control-btn" id="down-btn">↓</div>
        <div class="control-btn" id="right-btn">→</div>
        <div class="empty"></div>
    </div>
    <div class="toggle-btn" id="toggle-btn">Jump1</div>
    <div class="reset-btn" id="reset-btn">Reset</div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const virtualWidth = 1600;
        const virtualHeight = 900;
        let scale = 1;

        const gridWidth = 16;
        const gridHeight = 8;
        const cellWidth = virtualWidth / gridWidth;
        const cellHeight = (virtualHeight * (gridHeight / 9)) / gridHeight;
        const statusBarHeight = virtualHeight / 9;

        let currentLevel = 1;
        let levelName = "Level 1";
        let hasWon = false;

        let isInputActive = false;
        let movementMode = 'jump1';
        let isPlayerDead = false;
        let movement_lock = false;
        let grid = [];
        let can_be_killed = 1; // Initialize can_be_killed to 1 (vulnerable)

        let slipping = false;
        let slipDir = { dx: 0, dy: 0 };

        function draw() {
            ctx.save();
            ctx.scale(scale, scale);
            ctx.clearRect(0, 0, virtualWidth, virtualHeight);

            const claimedTiles = grid.filter(cell => cell.state === 'claimed' || (cell.state === 'player' && !isPlayerDead)).length;
            const totalFloorTiles = grid.filter(cell => cell.state === 'floor' || cell.state === 'claimed' || (cell.state === 'player' && !isPlayerDead)).length;

            // Check for win condition
            hasWon = grid.every(cell => cell.state !== 'floor');

            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, 0, virtualWidth, statusBarHeight);
            ctx.fillStyle = '#666666';
            ctx.font = `${statusBarHeight * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${levelName} - ${movementMode}${isPlayerDead ? ' - Dead' : hasWon ? ' - Won' : ''} - ${claimedTiles}/${totalFloorTiles}`, virtualWidth / 2, statusBarHeight / 2);

            grid.forEach(cell => {
                if (cell.state === 'floor') ctx.fillStyle = '#8B8B83';
                else if (cell.state === 'claimed') ctx.fillStyle = '#D3D3D3';
                else if (cell.state === 'wall') ctx.fillStyle = '#5C5C5A';
                else if (cell.state === 'pit') ctx.fillStyle = '#000000';
                else if (cell.state === 'player') ctx.fillStyle = isPlayerDead ? '#FF0000' : '#00f';
                else if (cell.state === 'enemy-right' || cell.state === 'enemy-left') ctx.fillStyle = '#00FF00';
                ctx.fillRect(cell.x * cellWidth, statusBarHeight + cell.y * cellHeight, cellWidth, cellHeight);

                // Superimpose direction indicators for enemies
                if (cell.state === 'enemy-right' || cell.state === 'enemy-left') {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${cellHeight * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const symbol = cell.state === 'enemy-right' ? '>' : '<';
                    ctx.fillText(symbol, (cell.x + 0.5) * cellWidth, statusBarHeight + (cell.y + 0.5) * cellHeight);
                }
            });

            ctx.restore();
        }

        function initializeGrid(level) {
            const levels = {
                1: [
                    "################",
                    "#..>....~~.....#",
                    "#..####..####..#",
                    "#..#..#..#..#..#",
                    "#..####..####..#",
                    "#....~~........#",
                    "#......P.....<.#",
                    "################"
                ],
                2: [
                    "################",
                    "#..#....~~...P.#",
                    "#..#....~~...<.#",
                    "#..###.####..#.#",
                    "#....#.#..#..#.#",
                    "#....#....#....#",
                    "#.>..##.###....#",
                    "################"
                ]
            };

            grid = [];
            const staticLevel = levels[level] || levels[1]; // Default to Level 1
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    let char = staticLevel[y][x];
                    let state = 'floor';
                    let isClaimed = false;
                    if (char === '#') state = 'wall';
                    else if (char === '.') state = 'floor';
                    else if (char === 'P') state = 'player';
                    else if (char === '~') state = 'pit';
                    else if (char === '>') state = 'enemy-right';
                    else if (char === '<') state = 'enemy-left';
                    grid.push({ x, y, state, isClaimed });
                }
            }
            levelName = `Level ${level}`;
            can_be_killed = 1; // Reset can_be_killed on level initialization
        }

        function resizeCanvas() {
            const aspect = virtualWidth / virtualHeight;
            let width = window.innerWidth;
            let height = window.innerHeight;

            if (width / height > aspect) {
                canvas.height = height;
                canvas.width = height * aspect;
            } else {
                canvas.width = width;
                canvas.height = width / aspect;
            }

            scale = canvas.width / virtualWidth;
            draw();
        }

        function findPlayer() {
            return grid.find(cell => cell.state === 'player');
        }

        function attemptMove(dx, dy, claimStart = true) {
            const player = findPlayer();
            if (!player) return false;
            const newX = player.x + dx;
            const newY = player.y + dy;
            if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) return false;
            const target = grid.find(c => c.x === newX && c.y === newY);

            if (target.state === 'wall') return false;

            if (claimStart) {
                player.state = 'claimed';
                player.isClaimed = true;
            }

            target.isClaimed = target.isClaimed || (target.state === 'claimed');

            if (target.state === 'pit') {
                target.state = 'player';
                isPlayerDead = true;
                draw();
                return false;
            } else if (target.state.startsWith('enemy') && can_be_killed) {
                target.state = 'player';
                isPlayerDead = true;
                draw();
                return false;
            } else if (target.state === 'claimed') {
                target.state = 'player';
                draw();
                return 'slip';
            } else {
                target.state = 'player';
                draw();
                return true;
            }
        }

        function moveEnemies() {
            const enemies = grid.filter(cell => cell.state === 'enemy-right' || cell.state === 'enemy-left');
            const enemyUpdates = [];

            // Collect updates to avoid modifying grid during iteration
            enemies.forEach(enemy => {
                const currentState = enemy.state;
                const direction = currentState === 'enemy-right' ? 1 : -1;
                let nextX = enemy.x + direction;
                let nextY = enemy.y;
                let newState = currentState;
                let moveTo = null;

                // Check if next cell is valid
                if (nextX < 0 || nextX >= gridWidth || nextY < 0 || nextY >= gridHeight) {
                    // Out of bounds: switch direction
                    newState = currentState === 'enemy-right' ? 'enemy-left' : 'enemy-right';
                } else {
                    const nextCell = grid.find(c => c.x === nextX && c.y === nextY);
                    if (nextCell.state === 'wall' || nextCell.state === 'pit' || nextCell.state === 'enemy-right' || nextCell.state === 'enemy-left') {
                        // Blocked: switch direction
                        newState = currentState === 'enemy-right' ? 'enemy-left' : 'enemy-right';
                    } else {
                        // Valid move
                        moveTo = { x: nextX, y: nextY };
                    }
                }

                // If switching direction, try moving in the new direction
                if (newState !== currentState && !moveTo) {
                    const newDirection = newState === 'enemy-right' ? 1 : -1;
                    nextX = enemy.x + newDirection;
                    nextY = enemy.y;
                    if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                        const newCell = grid.find(c => c.x === nextX && c.y === nextY);
                        if (newCell.state !== 'wall' && newCell.state !== 'pit' && newCell.state !== 'enemy-right' && newCell.state !== 'enemy-left') {
                            moveTo = { x: nextX, y: nextY };
                        }
                    }
                }

                enemyUpdates.push({ enemy, newState, moveTo });
            });

            // Apply updates
            enemyUpdates.forEach(({ enemy, newState, moveTo }) => {
                if (moveTo) {
                    const targetCell = grid.find(c => c.x === moveTo.x && c.y === moveTo.y);
                    if (targetCell.state === 'player') {
                        isPlayerDead = true; // Player dies if enemy moves onto their tile
                        enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                        targetCell.isClaimed = targetCell.isClaimed || (targetCell.state === 'claimed');
                        targetCell.state = 'player'; // Keep player state to show death
                    } else {
                        // Move the enemy
                        enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                        targetCell.isClaimed = targetCell.isClaimed || (targetCell.state === 'claimed');
                        targetCell.state = newState;
                    }
                } else {
                    enemy.state = newState;
                }
            });

            draw();
        }

        function slipStep() {
            if (!slipping) return;
            moveEnemies(); // Move enemies at the start of each slip step
            const result = attemptMove(slipDir.dx, slipDir.dy);
            if (result === 'slip') {
                setTimeout(slipStep, 100);
            } else {
                slipping = false;
                movement_lock = false;
                can_be_killed = 1; // Reset can_be_killed after slipping ends
            }
        }

        function movePlayer(dx, dy) {
            if (isPlayerDead || movement_lock || hasWon || !can_be_killed) { 
                isInputActive = false; 
                return; 
            }

            movement_lock = true;
            can_be_killed = 0; // Set can_be_killed to 0 when player attempts to move

            const jumpDistance = movementMode === 'jump1' ? 1 : 2;
            const player = findPlayer();
            const oldX = player.x;
            const oldY = player.y;
            const newX = oldX + dx * jumpDistance;
            const newY = oldY + dy * jumpDistance;

            let validMove = true;
            if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) validMove = false;
            else {
                const intendedTarget = grid.find(c => c.x === newX && c.y === newY);
                if (intendedTarget.state === 'wall') validMove = false;
            }

            const playerOldCell = player;
            let playerTargetCell;
            let claimStart = validMove;
            if (!validMove) {
                playerTargetCell = playerOldCell;
                movement_lock = false;
                isInputActive = false;
                can_be_killed = 1; // Reset can_be_killed if move is invalid
                moveEnemies(); // Move enemies even on invalid move
                draw();
                return;
            } else {
                playerTargetCell = grid.find(c => c.x === newX && c.y === newY);
            }

            // Clear old player position
            if (claimStart) {
                playerOldCell.state = 'claimed';
                playerOldCell.isClaimed = true;
            }

            // Place player
            playerTargetCell.isClaimed = playerTargetCell.isClaimed || (playerTargetCell.state === 'claimed');
            let result;
            if (playerTargetCell.state === 'pit') {
                playerTargetCell.state = 'player';
                isPlayerDead = true;
                result = false;
            } else if (playerTargetCell.state.startsWith('enemy') && can_be_killed) {
                playerTargetCell.state = 'player';
                isPlayerDead = true;
                result = false;
            } else if (playerTargetCell.state === 'claimed') {
                playerTargetCell.state = 'player';
                result = 'slip';
            } else {
                playerTargetCell.state = 'player';
                result = true;
            }

            draw();
            moveEnemies(); // Move enemies after player moves
            can_be_killed = 1; // Reset can_be_killed after enemies move

            if (result === 'slip') {
                slipping = true;
                slipDir = { dx, dy };
                setTimeout(slipStep, 100);
            } else {
                movement_lock = false;
            }
            isInputActive = false;
        }

        function toggleMovementMode() {
            if (isPlayerDead || slipping || hasWon || !can_be_killed) return;
            movementMode = movementMode === 'jump1' ? 'jump2' : 'jump1';
            document.getElementById('toggle-btn').textContent = movementMode === 'jump1' ? 'Jump1' : 'Jump2';
            draw();
        }

        function resetLevel() {
            isPlayerDead = false;
            hasWon = false;
            movementMode = 'jump1';
            document.getElementById('toggle-btn').textContent = 'Jump1';
            initializeGrid(currentLevel); // Reset to current level
            draw();
            movement_lock = false;
            slipping = false;
            can_be_killed = 1; // Reset can_be_killed
        }

        function resetGame() {
            currentLevel = 1;
            resetLevel();
        }

        function changeLevel(direction) {
            isPlayerDead = false;
            hasWon = false;
            movementMode = 'jump1';
            document.getElementById('toggle-btn').textContent = 'Jump1';
            currentLevel = direction === 'next' ? (currentLevel === 1 ? 2 : 1) : (currentLevel === 2 ? 1 : 1);
            initializeGrid(currentLevel);
            draw();
            movement_lock = false;
            slipping = false;
            can_be_killed = 1; // Reset can_be_killed
        }

        // Input events
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('keydown', (e) => {
            if (isInputActive || slipping || !can_be_killed) return;
            isInputActive = true;
            switch (e.key.toLowerCase()) {
                case 'arrowup': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, -1); break;
                case 'arrowdown': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, 1); break;
                case 'arrowleft': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(-1, 0); break;
                case 'arrowright': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(1, 0); break;
                case ' ': 
                    if (hasWon) changeLevel('next');
                    else if (isPlayerDead) resetLevel();
                    else toggleMovementMode();
                    break;
                case 'q': changeLevel('previous'); break;
                case 'w': changeLevel('next'); break;
            }
        });
        window.addEventListener('keyup', (e) => {
            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                movement_lock = false;
            }
            isInputActive = false;
        });

        // On-screen buttons
        const buttons = { 'up-btn': [0, -1], 'down-btn': [0, 1], 'left-btn': [-1, 0], 'right-btn': [1, 0] };
        Object.keys(buttons).forEach(id => {
            const btn = document.getElementById(id);
            const [dx, dy] = buttons[id];
            function press(e) { e.preventDefault(); if (!isInputActive && !isPlayerDead && !movement_lock && !slipping && !hasWon && can_be_killed) { isInputActive = true; movePlayer(dx, dy); } }
            function release(e) { e.preventDefault(); isInputActive = false; movement_lock = false; }
            btn.addEventListener('mousedown', press); btn.addEventListener('mouseup', release);
            btn.addEventListener('touchstart', press); btn.addEventListener('touchend', release);
        });

        // Toggle button
        const toggleBtn = document.getElementById('toggle-btn');
        toggleBtn.addEventListener('mousedown', e => { e.preventDefault(); if (!isInputActive && !isPlayerDead && !slipping && !hasWon && can_be_killed) { isInputActive = true; toggleMovementMode(); } });
        toggleBtn.addEventListener('mouseup', e => { e.preventDefault(); isInputActive = false; });
        toggleBtn.addEventListener('touchstart', e => { e.preventDefault(); if (!isPlayerDead && !slipping && !hasWon && can_be_killed) { isInputActive = true; toggleMovementMode(); } });
        toggleBtn.addEventListener('touchend', e => { e.preventDefault(); isInputActive = false; });

        // Reset button
        const resetBtn = document.getElementById('reset-btn');
        function resetPress(e) { e.preventDefault(); if (!isInputActive) { isInputActive = true; resetGame(); } }
        function resetRelease(e) { e.preventDefault(); isInputActive = false; }
        resetBtn.addEventListener('mousedown', resetPress); resetBtn.addEventListener('mouseup', resetRelease);
        resetBtn.addEventListener('touchstart', resetPress); resetBtn.addEventListener('touchend', resetRelease);

        // Init
        initializeGrid(currentLevel);
        resizeCanvas();
    </script>
</body>
</html>