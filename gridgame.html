<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWSS 2: Recrudescence</title>
    <style>
        html { height: 100%; }
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #000; overflow: hidden; position: relative; }
        canvas { display: none; background-color: #222; }
        .controls {
            position: absolute;
            bottom: calc(10px + env(safe-area-inset-bottom));
            right: calc(10px + env(safe-area-inset-right));
            display: grid;
            grid-template-columns: repeat(3, minmax(40px, 8vw));
            grid-template-rows: repeat(2, minmax(40px, 8vw));
            gap: 5px;
            z-index: 10;
            display: none;
        }
        .toggle-btn, .reset-btn {
            position: absolute;
            bottom: calc(10px + env(safe-area-inset-bottom));
            left: calc(10px + env(safe-area-inset-left));
            width: minmax(100px, 15vw);
            height: 8vh;
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(16px, 2.5vw, 18px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            z-index: 10;
            display: none;
        }
        .reset-btn { bottom: calc(100px + env(safe-area-inset-bottom)); }
        .toggle-btn:active, .reset-btn:active { background-color: #777; }
        .control-btn {
            background-color: rgba(85, 85, 85, 0.7);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 3vw, 24px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .control-btn:active { background-color: rgba(119, 119, 119, 0.7); }
        .empty { background: none; border: none; }
        .title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 20;
        }
        .title-text {
            color: #fff;
            font-size: clamp(24px, 6vw, 48px);
            font-family: Arial, sans-serif;
            margin-top: 5vh;
            text-align: center;
        }
        .level-select {
            color: #fff;
            font-size: clamp(18px, 4vw, 32px);
            font-family: Arial, sans-serif;
            margin: 5vh 0;
            text-align: center;
        }
        .title-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .title-btn {
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: clamp(14px, 2.5vw, 18px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
        }
        .title-btn:active {
            background-color: #777;
        }
        @media (max-width: 600px) {
            .controls {
                grid-template-columns: repeat(3, minmax(30px, 10vw));
                grid-template-rows: repeat(2, minmax(30px, 10vw));
                gap: 3px;
                right: calc(5px + env(safe-area-inset-right));
                bottom: calc(5px + env(safe-area-inset-bottom));
            }
            .toggle-btn, .reset-btn {
                width: minmax(80px, 18vw);
                height: 6vh;
                font-size: clamp(14px, 3vw, 16px);
                left: calc(5px + env(safe-area-inset-left));
            }
            .reset-btn { bottom: calc(80px + env(safe-area-inset-bottom)); }
            .control-btn {
                font-size: clamp(16px, 3.5vw, 20px);
            }
            .title-text {
                font-size: clamp(20px, 5vw, 36px);
            }
            .level-select {
                font-size: clamp(16px, 3.5vw, 24px);
            }
            .title-btn {
                font-size: clamp(12px, 2vw, 16px);
                padding: 8px 15px;
                min-width: 60px;
            }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            .controls {
                grid-template-columns: repeat(3, minmax(25px, 7vw));
                grid-template-rows: repeat(2, minmax(25px, 7vw));
                gap: 2px;
            }
            .toggle-btn, .reset-btn {
                width: minmax(70px, 14vw);
                height: 6vh;
                font-size: clamp(12px, 2.5vw, 14px);
            }
            .reset-btn { bottom: calc(70px + env(safe-area-inset-bottom)); }
            .title-text {
                font-size: clamp(18px, 4vw, 32px);
                margin-top: 3vh;
            }
            .level-select {
                font-size: clamp(14px, 3vw, 20px);
                margin: 3vh 0;
            }
            .title-btn {
                font-size: clamp(10px, 1.8vw, 14px);
                padding: 6px 12px;
                min-width: 50px;
            }
        }
    </style>
</head>
<body>
    <div class="title-screen">
        <div class="title-text">SWSS 2: Recrudescence</div>
        <div class="level-select" id="level-select">Level 1 - Temple</div>
        <div class="title-buttons">
            <div class="title-btn" id="prev-level-btn">Previous</div>
            <div class="title-btn" id="play-btn">Play</div>
            <div class="title-btn" id="next-level-btn">Next</div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <div class="empty"></div>
        <div class="control-btn" id="up-btn">↑</div>
        <div class="empty"></div>
        <div class="control-btn" id="left-btn">←</div>
        <div class="control-btn" id="down-btn">↓</div>
        <div class="control-btn" id="right-btn">→</div>
        <div class="empty"></div>
    </div>
    <div class="toggle-btn" id="toggle-btn">Jump1</div>
    <div class="reset-btn" id="reset-btn">Menu</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const titleScreen = document.querySelector('.title-screen');
    const levelSelectDisplay = document.getElementById('level-select');
    const playBtn = document.getElementById('play-btn');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const prevLevelBtn = document.getElementById('prev-level-btn');
    const resetBtn = document.getElementById('reset-btn');

    const virtualWidth = 1600;
    const virtualHeight = 900;
    let scale = 1;

    const gridWidth = 16;
    const gridHeight = 8;
    const cellWidth = virtualWidth / gridWidth;
    const cellHeight = (virtualHeight * (gridHeight / 9)) / gridHeight;
    const statusBarHeight = virtualHeight / 9;

    let selectedLevel = 1;
    let currentLevel = 1;
    let levelName = "Level 1 - Temple";
    let hasWon = false;

    let isInputActive = false;
    let movementMode = 'jump1';
    let isPlayerDead = false;
    let movement_lock = false;
    let grid = [];
    let can_be_killed = 1;
    let moveCount = 0;

    let slipping = false;
    let slipDir = { dx: 0, dy: 0 };

    let totalFloorTiles = 0;
    let particles = [];

    const levels = {
        1: { name: "Temple", layout: [
            "################",
            "#..>....~~.....#",
            "#..####..####..#",
            "#..#..#..#..#..#",
            "#..####..####..#",
            "#....~~........#",
            "#......P.....<.#",
            "################"
        ]},
        2: { name: "Cave", layout: [
            "################",
            "#..#....~~...P.#",
            "#..#....~~...<.#",
            "#..###.####..#.#",
            "#....#.#..#..#v#",
            "#....#....#....#",
            "#.>..##.###....#",
            "################"
        ]}
    };

    function updateLevelSelectDisplay() {
        levelSelectDisplay.textContent = `Level ${selectedLevel} - ${levels[selectedLevel].name}`;
    }

    function createParticles(x, y) {
        const particleCount = 12;
        const tileLeft = x * cellWidth;
        const tileRight = (x + 1) * cellWidth;
        const tileTop = statusBarHeight + y * cellHeight;
        const tileBottom = statusBarHeight + (y + 1) * cellHeight;
        const inset = 0.1;

        const spawnPoints = [
            { px: tileLeft + inset * cellWidth, py: tileTop + inset * cellHeight, vx: -50, vy: -50 },
            { px: tileRight - inset * cellWidth, py: tileTop + inset * cellHeight, vx: 50, vy: -50 },
            { px: tileLeft + inset * cellWidth, py: tileBottom - inset * cellHeight, vx: -50, vy: 50 },
            { px: tileRight - inset * cellWidth, py: tileBottom - inset * cellHeight, vx: 50, vy: 50 },
            { px: tileLeft + cellWidth / 2, py: tileTop + inset * cellHeight, vx: 0, vy: -75 },
            { px: tileRight - inset * cellWidth, py: tileTop + cellHeight / 2, vx: 75, vy: 0 },
            { px: tileLeft + cellWidth / 2, py: tileBottom - inset * cellHeight, vx: 0, vy: 75 },
            { px: tileLeft + inset * cellWidth, py: tileTop + cellHeight / 2, vx: -75, vy: 0 },
            { px: tileLeft + inset * cellWidth, py: tileTop + cellHeight / 3, vx: -60, vy: -30 },
            { px: tileRight - inset * cellWidth, py: tileTop + 2 * cellHeight / 3, vx: 60, vy: 30 },
            { px: tileLeft + cellWidth / 3, py: tileTop + inset * cellHeight, vx: -30, vy: -60 },
            { px: tileRight - cellWidth / 3, py: tileBottom - inset * cellHeight, vx: 30, vy: 60 }
        ];

        for (let i = 0; i < particleCount; i++) {
            const sp = spawnPoints[i % spawnPoints.length];
            particles.push({
                x: sp.px,
                y: sp.py,
                vx: sp.vx + (Math.random() - 0.5) * 20,
                vy: sp.vy + (Math.random() - 0.5) * 20,
                size: 20,
                moveTime: 0.5,
                isStatic: false,
                rotation: Math.random() * 360,
                rotationSpeed: (Math.random() - 0.5) * 180
            });
        }

        for (let i = 0; i < (particleCount * 2); i++) {
            const sp = spawnPoints[i % spawnPoints.length];
            particles.push({
                x: sp.px,
                y: sp.py,
                vx: sp.vx + (Math.random() - 0.5) * 200,
                vy: sp.vy + (Math.random() - 0.5) * 200,
                size: 10,
                moveTime: 0.25,
                isStatic: false,
                rotation: Math.random() * 360,
                rotationSpeed: (Math.random() - 0.5) * 360
            });
        }
    }

    function updateParticles(deltaTime) {
        particles.forEach(p => {
            if (!p.isStatic) {
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.moveTime -= deltaTime;

                const gridX = Math.floor(p.x / cellWidth);
                const gridY = Math.floor((p.y - statusBarHeight) / cellHeight);

                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                    const cell = grid.find(c => c.x === gridX && c.y === gridY);
                    if (cell && (cell.state === 'wall' || cell.state === 'pit')) {
                        p.isStatic = true;
                    }
                } else {
                    p.isStatic = true;
                }

                if (p.moveTime <= 0) {
                    p.isStatic = true;
                }
            }
        });
    }

    function draw() {
        ctx.save();
        ctx.scale(scale, scale);
        ctx.clearRect(0, 0, virtualWidth, virtualHeight);

        const claimedTiles = grid.filter(cell => cell.isClaimed || cell.state === 'player').length;

        hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed || cell.state === 'player');

        ctx.fillStyle = '#F5F5F5';
        ctx.fillRect(0, 0, virtualWidth, statusBarHeight);
        ctx.fillStyle = '#666666';
        ctx.font = `${statusBarHeight * 0.5}px Arial`;
        ctx.textBaseline = 'middle';

        ctx.textAlign = 'left';
        ctx.fillText(levelName, 10, statusBarHeight / 2);

        ctx.textAlign = 'right';
        ctx.fillText(`${movementMode}${isPlayerDead ? ' - Dead' : hasWon ? ' - Won' : ''} - Moves: ${moveCount} - Claimed: ${claimedTiles}/${totalFloorTiles}`, virtualWidth - 10, statusBarHeight / 2);

        grid.forEach(cell => {
            if (cell.state === 'floor') ctx.fillStyle = '#8B8B83';
            else if (cell.state === 'claimed') ctx.fillStyle = '#D3D3D3';
            else if (cell.state === 'wall') ctx.fillStyle = '#5C5C5A';
            else if (cell.state === 'pit') ctx.fillStyle = '#000000';
            else if (cell.state === 'player') ctx.fillStyle = isPlayerDead ? '#FF0000' : hasWon ? '#00FF00' : '#00f';
            else if (cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down') ctx.fillStyle = '#00FF00';
            ctx.fillRect(cell.x * cellWidth, statusBarHeight + cell.y * cellHeight, cellWidth, cellHeight);

            if (cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down') {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `${cellHeight * 0.8}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let symbol;
                switch (cell.state) {
                    case 'enemy-right': symbol = '>'; break;
                    case 'enemy-left': symbol = '<'; break;
                    case 'enemy-up': symbol = '^'; break;
                    case 'enemy-down': symbol = 'v'; break;
                }
                ctx.fillText(symbol, (cell.x + 0.5) * cellWidth, statusBarHeight + (cell.y + 0.5) * cellHeight);
            }

            if (cell.state === 'player') {
                ctx.fillStyle = '#FFFFFF';
                ctx.font = `${cellHeight * 0.8}px "Segoe UI Emoji", Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const centerX = (cell.x + 0.5) * cellWidth;
                const centerY = statusBarHeight + (cell.y + 0.5) * cellHeight;
                if (isPlayerDead) {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate(Math.PI);
                    ctx.fillText('🧙‍♀️', 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillText('🧙‍♀️', centerX, centerY);
                }
            }
        });

        particles.forEach(p => {
            ctx.fillStyle = p.isStatic ? 'rgba(255, 0, 0, 0.8)' : `rgba(255, 0, 0, ${1 - p.moveTime / 0.5})`;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });

        ctx.restore();

        // Update reset button text
        resetBtn.textContent = isPlayerDead ? 'Reset' : 'Menu';
    }

    let lastTime = 0;
    function animate(timestamp) {
        if (lastTime === 0) lastTime = timestamp;
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        updateParticles(deltaTime);
        draw();

        requestAnimationFrame(animate);
    }

    function initializeGrid(level) {
        grid = [];
        const staticLevel = levels[level] || levels[1];
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let char = staticLevel.layout[y][x];
                let state = 'floor';
                let isClaimed = false;
                if (char === '#') state = 'wall';
                else if (char === '.') state = 'floor';
                else if (char === 'P') state = 'player';
                else if (char === '~') state = 'pit';
                else if (char === '>') state = 'enemy-right';
                else if (char === '<') state = 'enemy-left';
                else if (char === '^') state = 'enemy-up';
                else if (char === 'v') state = 'enemy-down';
                grid.push({ x, y, state, isClaimed });
            }
        }
        totalFloorTiles = grid.filter(cell => cell.state !== 'wall' && cell.state !== 'pit').length;
        levelName = `Level ${level} - ${staticLevel.name}`;
        currentLevel = level;
        can_be_killed = 1;
        moveCount = 0;
        particles = [];
    }

    function setBodyHeight() {
        document.body.style.height = `${window.innerHeight}px`;
    }

    function resizeCanvas() {
        setBodyHeight();
        const aspect = virtualWidth / virtualHeight;
        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width / height > aspect) {
            canvas.height = height;
            canvas.width = height * aspect;
        } else {
            canvas.width = width;
            canvas.height = width / aspect;
        }

        scale = canvas.width / virtualWidth;
        draw();
    }

    function showTitleScreen() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
        particles = [];
        moveCount = 0;
        document.getElementById('toggle-btn').textContent = 'Jump1';
        titleScreen.style.display = 'flex';
        canvas.style.display = 'none';
        document.querySelector('.controls').style.display = 'none';
        document.querySelector('.toggle-btn').style.display = 'none';
        document.querySelector('.reset-btn').style.display = 'none';
        updateLevelSelectDisplay();
    }

    function showGame() {
        titleScreen.style.display = 'none';
        canvas.style.display = 'block';
        document.querySelector('.controls').style.display = 'grid';
        document.querySelector('.toggle-btn').style.display = 'flex';
        document.querySelector('.reset-btn').style.display = 'flex';
        initializeGrid(selectedLevel);
        resetBtn.textContent = 'Menu';
        resizeCanvas();
        requestAnimationFrame(animate);
    }

    function findPlayer() {
        return grid.find(cell => cell.state === 'player');
    }

    function attemptMove(dx, dy, claimStart = true) {
        const player = findPlayer();
        if (!player) return false;
        const newX = player.x + dx;
        const newY = player.y + dy;
        if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) return false;
        const target = grid.find(c => c.x === newX && c.y === newY);

        if (target.state === 'wall') return false;

        if (claimStart) {
            player.isClaimed = true;
            player.state = 'claimed';
        }

        if (target.state === 'pit') {
            target.state = 'player';
            isPlayerDead = true;
            createParticles(newX, newY);
            draw();
            return false;
        } else if (target.state.startsWith('enemy')) {
            return 'enemy';
        } else if (target.isClaimed) {
            target.state = 'player';
            draw();
            return 'slip';
        } else {
            target.state = 'player';
            draw();
            return true;
        }
    }

    function moveEnemies() {
        const enemies = grid.filter(cell => cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down');
        const enemyUpdates = [];
        const swaps = new Map();

        enemies.forEach(enemy => {
            const currentState = enemy.state;
            let dx = 0, dy = 0;
            let newState = currentState;
            let moveTo = null;

            if (currentState === 'enemy-right') dx = 1;
            else if (currentState === 'enemy-left') dx = -1;
            else if (currentState === 'enemy-up') dy = -1;
            else if (currentState === 'enemy-down') dy = 1;

            let nextX = enemy.x + dx;
            let nextY = enemy.y + dy;

            if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                const nextCell = grid.find(c => c.x === nextX && c.y === nextY);
                if (nextCell.state !== 'wall' && nextCell.state !== 'pit') {
                    const targetEnemy = enemies.find(e => e.x === nextX && e.y === nextY);
                    if (targetEnemy) {
                        let targetDx = 0, targetDy = 0;
                        if (targetEnemy.state === 'enemy-right') targetDx = 1;
                        else if (targetEnemy.state === 'enemy-left') targetDx = -1;
                        else if (targetEnemy.state === 'enemy-up') targetDy = -1;
                        else if (targetEnemy.state === 'enemy-down') targetDy = 1;
                        if (targetEnemy.x + targetDx === enemy.x && targetEnemy.y + targetDy === enemy.y) {
                            const key = `${Math.min(enemy.x, nextX)},${Math.min(enemy.y, nextY)}-${Math.max(enemy.x, nextX)},${Math.max(enemy.y, nextY)}`;
                            if (!swaps.has(key)) {
                                swaps.set(key, [
                                    { enemy, target: { x: nextX, y: nextY }, newState: enemy.state },
                                    { enemy: targetEnemy, target: { x: enemy.x, y: enemy.y }, newState: targetEnemy.state }
                                ]);
                            }
                        } else {
                            if (currentState === 'enemy-right') newState = 'enemy-left';
                            else if (currentState === 'enemy-left') newState = 'enemy-right';
                            else if (currentState === 'enemy-up') newState = 'enemy-down';
                            else if (currentState === 'enemy-down') newState = 'enemy-up';
                        }
                    } else {
                        moveTo = { x: nextX, y: nextY };
                    }
                } else {
                    if (currentState === 'enemy-right') newState = 'enemy-left';
                    else if (currentState === 'enemy-left') newState = 'enemy-right';
                    else if (currentState === 'enemy-up') newState = 'enemy-down';
                    else if (currentState === 'enemy-down') newState = 'enemy-up';
                }
            } else {
                if (currentState === 'enemy-right') newState = 'enemy-left';
                else if (currentState === 'enemy-left') newState = 'enemy-right';
                else if (currentState === 'enemy-up') newState = 'enemy-down';
                else if (currentState === 'enemy-down') newState = 'enemy-up';
            }

            enemyUpdates.push({ enemy, newState, moveTo });
        });

        const landingPositions = new Map();
        enemyUpdates.forEach((update, index) => {
            if (swaps.has(`${update.enemy.x},${update.enemy.y}-${update.moveTo?.x},${update.moveTo?.y}`)) {
                return;
            }
            if (update.moveTo) {
                const key = `${update.moveTo.x},${update.moveTo.y}`;
                if (!landingPositions.has(key)) landingPositions.set(key, []);
                landingPositions.get(key).push({ update, index });
            }
        });

        landingPositions.forEach((targeters, key) => {
            if (targeters.length > 1) {
                targeters.forEach(({ update }) => {
                    const currentState = update.enemy.state;
                    if (currentState === 'enemy-right') update.newState = 'enemy-left';
                    else if (currentState === 'enemy-left') update.newState = 'enemy-right';
                    else if (currentState === 'enemy-up') update.newState = 'enemy-down';
                    else if (currentState === 'enemy-down') update.newState = 'enemy-up';
                    update.moveTo = null;
                });
            }
        });

        enemyUpdates.forEach((update, index) => {
            if (!update.moveTo && update.newState !== update.enemy.state && !swaps.has(`${update.enemy.x},${update.enemy.y}-*`)) {
                let dx = 0, dy = 0;
                if (update.newState === 'enemy-right') dx = 1;
                else if (update.newState === 'enemy-left') dx = -1;
                else if (update.newState === 'enemy-up') dy = -1;
                else if (update.newState === 'enemy-down') dy = 1;

                const nextX = update.enemy.x + dx;
                const nextY = update.enemy.y + dy;
                if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                    const newCell = grid.find(c => c.x === nextX && c.y === nextY);
                    const key = `${nextX},${nextY}`;
                    const otherTargeters = landingPositions.get(key)?.filter(t => t.index !== index) || [];
                    if (newCell.state !== 'wall' && newCell.state !== 'pit' && otherTargeters.length === 0 && !swaps.has(`*-${nextX},${nextY}`)) {
                        update.moveTo = { x: nextX, y: nextY };
                        landingPositions.set(key, [{ update, index }]);
                    }
                }
            }
        });

        swaps.forEach(swap => {
            const swapUpdates = swap.map(({ enemy, target, newState }) => ({
                enemy,
                target,
                newState,
                isClaimed: enemy.isClaimed
            }));
            swapUpdates.forEach(({ enemy, isClaimed }) => {
                enemy.state = isClaimed ? 'claimed' : 'floor';
            });
            swapUpdates.forEach(({ enemy, target, newState }) => {
                const targetCell = grid.find(c => c.x === target.x && c.y === target.y);
                if (targetCell.state === 'player') {
                    isPlayerDead = true;
                    createParticles(target.x, target.y);
                    enemy.state = isClaimed ? 'claimed' : 'floor';
                    targetCell.state = 'player';
                } else {
                    targetCell.state = newState;
                }
            });
        });

        enemyUpdates.forEach(({ enemy, newState, moveTo }) => {
            const swapKey = [...swaps.keys()].find(key => key.includes(`${enemy.x},${enemy.y}`));
            if (swapKey) return;

            if (moveTo) {
                const targetCell = grid.find(c => c.x === moveTo.x && c.y === moveTo.y);
                if (targetCell.state === 'player') {
                    isPlayerDead = true;
                    createParticles(moveTo.x, moveTo.y);
                    enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                    targetCell.state = 'player';
                } else {
                    enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                    targetCell.state = newState;
                }
            } else {
                enemy.state = newState;
            }
        });

        draw();
    }

    function slipStep() {
        if (!slipping) return;

        const player = findPlayer();
        if (!player) return;

        if (isPlayerDead) {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
            draw();
            return;
        }

        const dx = slipDir.dx;
        const dy = slipDir.dy;
        const newX = player.x + dx;
        const newY = player.y + dy;
        const target = grid.find(c => c.x === newX && c.y === newY);

        let result = attemptMove(dx, dy);

        if (result === 'enemy') {
            moveEnemies();
            if (target.state.startsWith('enemy')) {
                target.state = 'player';
                isPlayerDead = true;
                createParticles(player.x, player.y);
                result = false;
            } else {
                target.state = 'player';
                result = target.isClaimed ? 'slip' : true;
            }
            draw();
        } else {
            if (result === false && !isPlayerDead) {
                slipping = false;
                movement_lock = false;
                can_be_killed = 1;
                return;
            }
            moveEnemies();
        }

        if (result === 'slip' && !isPlayerDead) {
            setTimeout(slipStep, 100);
        } else {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
        }
    }

    function movePlayer(dx, dy) {
        if (isPlayerDead || movement_lock || hasWon || !can_be_killed) {
            isInputActive = false;
            return;
        }

        moveCount++;

        movement_lock = true;
        can_be_killed = 0;

        const jumpDistance = movementMode === 'jump1' ? 1 : 2;
        const player = findPlayer();
        const oldX = player.x;
        const oldY = player.y;
        const newX = oldX + dx * jumpDistance;
        const newY = oldY + dy * jumpDistance;

        let validMove = true;
        if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) validMove = false;
        else {
            const intendedTarget = grid.find(c => c.x === newX && c.y === newY);
            if (intendedTarget.state === 'wall') validMove = false;
        }

        const playerOldCell = player;
        let playerTargetCell;
        let claimStart = validMove;
        if (!validMove) {
            playerTargetCell = playerOldCell;
            movement_lock = false;
            isInputActive = false;
            can_be_killed = 1;
            moveEnemies();
            draw();
            return;
        } else {
            playerTargetCell = grid.find(c => c.x === newX && c.y === newY);
        }

        if (claimStart) {
            playerOldCell.isClaimed = true;
            playerOldCell.state = 'claimed';
        }

        let result;
        let enemyThere = playerTargetCell.state.startsWith('enemy');

        if (playerTargetCell.state === 'pit') {
            playerTargetCell.state = 'player';
            isPlayerDead = true;
            createParticles(newX, newY);
            result = false;
        } else if (!enemyThere) {
            playerTargetCell.state = 'player';
            if (playerTargetCell.isClaimed) {
                result = 'slip';
            } else {
                result = true;
            }
        }

        hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed);

        draw();
        moveEnemies();
        can_be_killed = 1;

        if (enemyThere) {
            if (playerTargetCell.state.startsWith('enemy')) {
                playerTargetCell.state = 'player';
                isPlayerDead = true;
                createParticles(newX, newY);
                result = false;
                draw();
            } else {
                playerTargetCell.state = 'player';
                if (playerTargetCell.isClaimed) {
                    result = 'slip';
                } else {
                    result = true;
                }
                draw();
            }
            hasWon = grid.every(cell => cell.state === 'wall' || cell.state === 'pit' || cell.isClaimed);
        }

        if (result === 'slip') {
            slipping = true;
            slipDir = { dx, dy };
            setTimeout(slipStep, 100);
        } else {
            movement_lock = false;
        }
        isInputActive = false;
    }

    function toggleMovementMode() {
        if (isPlayerDead || slipping || hasWon || !can_be_killed) return;
        movementMode = movementMode === 'jump1' ? 'jump2' : 'jump1';
        document.getElementById('toggle-btn').textContent = movementMode === 'jump1' ? 'Jump1' : 'Jump2';
        draw();
    }

    function resetLevel() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        initializeGrid(currentLevel);
        moveCount = 0;
        particles = [];
        draw();
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
    }

    function changeLevel(direction) {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        selectedLevel = direction === 'next' ? (selectedLevel === 1 ? 2 : 1) : (selectedLevel === 2 ? 1 : 2);
        currentLevel = selectedLevel;
        initializeGrid(currentLevel);
        moveCount = 0;
        particles = [];
        draw();
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
        showTitleScreen();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    window.addEventListener('keydown', (e) => {
        if (isInputActive || slipping || !can_be_killed || titleScreen.style.display !== 'none') return;
        isInputActive = true;
        switch (e.key.toLowerCase()) {
            case 'arrowup': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, -1); break;
            case 'arrowdown': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, 1); break;
            case 'arrowleft': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(-1, 0); break;
            case 'arrowright': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(1, 0); break;
            case ' ': 
                if (hasWon) changeLevel('next');
                else if (isPlayerDead) resetLevel();
                else toggleMovementMode();
                break;
            case 'q': changeLevel('previous'); break;
            case 'w': changeLevel('next'); break;
            case 'escape':
                showTitleScreen();
                break;
        }
        isInputActive = false;
    });
    window.addEventListener('keyup', (e) => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            movement_lock = false;
        }
        isInputActive = false;
    });

    const buttons = { 'up-btn': [0, -1], 'down-btn': [0, 1], 'left-btn': [-1, 0], 'right-btn': [1, 0] };
    Object.keys(buttons).forEach(id => {
        const btn = document.getElementById(id);
        const [dx, dy] = buttons[id];
        function press(e) {
            e.preventDefault();
            e.stopPropagation();
            if (!isInputActive && !isPlayerDead && !movement_lock && !slipping && !hasWon && can_be_killed) {
                isInputActive = true;
                movePlayer(dx, dy);
            }
        }
        function release(e) {
            e.preventDefault();
            e.stopPropagation();
            isInputActive = false;
            movement_lock = false;
        }
        btn.addEventListener('mousedown', press);
        btn.addEventListener('mouseup', release);
        btn.addEventListener('touchstart', press);
        btn.addEventListener('touchend', release);
    });

    const toggleBtn = document.getElementById('toggle-btn');
    toggleBtn.addEventListener('mousedown', e => {
        e.preventDefault();
        e.stopPropagation();
        if (!isInputActive && !isPlayerDead && !slipping && !hasWon && can_be_killed) {
            isInputActive = true;
            toggleMovementMode();
        }
    });
    toggleBtn.addEventListener('mouseup', e => {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    });
    toggleBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        e.stopPropagation();
        if (!isPlayerDead && !slipping && !hasWon && can_be_killed) {
            isInputActive = true;
            toggleMovementMode();
        }
    });
    toggleBtn.addEventListener('touchend', e => {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    });

    function resetOrMenu() {
        if (isPlayerDead) {
            resetLevel();
        } else {
            showTitleScreen();
        }
    }

    function resetPress(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!isInputActive) {
            isInputActive = true;
            resetOrMenu();
            isInputActive = false;
        }
    }
    function resetRelease(e) {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    }
    resetBtn.addEventListener('mousedown', resetPress);
    resetBtn.addEventListener('mouseup', resetRelease);
    resetBtn.addEventListener('touchstart', resetPress);
    resetBtn.addEventListener('touchend', resetRelease);

    // Title screen button events
    playBtn.addEventListener('click', e => {
        e.preventDefault();
        showGame();
    });
    playBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        showGame();
    });

    nextLevelBtn.addEventListener('click', e => {
        e.preventDefault();
        selectedLevel = selectedLevel === 1 ? 2 : 1;
        updateLevelSelectDisplay();
    });
    nextLevelBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        selectedLevel = selectedLevel === 1 ? 2 : 1;
        updateLevelSelectDisplay();
    });

    prevLevelBtn.addEventListener('click', e => {
        e.preventDefault();
        selectedLevel = selectedLevel === 2 ? 1 : 2;
        updateLevelSelectDisplay();
    });
    prevLevelBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        selectedLevel = selectedLevel === 2 ? 1 : 2;
        updateLevelSelectDisplay();
    });

    // Add touch event for level transition on win state
    document.body.addEventListener('touchstart', e => {
        e.preventDefault();
        if (hasWon && !isInputActive && titleScreen.style.display === 'none') {
            isInputActive = true;
            changeLevel('next');
            isInputActive = false;
        }
    });

    // Initialize title screen
    updateLevelSelectDisplay();
    showTitleScreen();
</script>
</body>
</html>