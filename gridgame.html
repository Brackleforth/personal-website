<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SWSS 2: Recrudescence</title>
    <style>
        html { height: 100%; }
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; background-color: #000; overflow: hidden; position: relative; }
        canvas { display: none; background-color: #222; }
        .controls {
            position: absolute;
            bottom: calc(10px + env(safe-area-inset-bottom));
            right: calc(10px + env(safe-area-inset-right));
            display: grid;
            grid-template-columns: repeat(3, minmax(40px, 8vw));
            grid-template-rows: repeat(2, minmax(40px, 8vw));
            gap: 5px;
            z-index: 10;
            display: none;
        }
        .toggle-btn, .reset-btn {
            position: absolute;
            bottom: calc(10px + env(safe-area-inset-bottom));
            left: calc(10px + env(safe-area-inset-left));
            width: minmax(100px, 15vw);
            height: 8vh;
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(16px, 2.5vw, 18px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            z-index: 10;
            display: none;
        }
        .reset-btn { bottom: calc(100px + env(safe-area-inset-bottom)); }
        .toggle-btn:active, .reset-btn:active { background-color: #777; }
        .control-btn {
            background-color: rgba(85, 85, 85, 0.7);
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(20px, 3vw, 24px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }
        .control-btn:active { background-color: rgba(119, 119, 119, 0.7); }
        .empty { background: none; border: none; }
        .title-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            z-index: 20;
        }
        .title-text {
            color: #fff;
            font-size: clamp(24px, 6vw, 48px);
            font-family: Arial, sans-serif;
            margin-top: 5vh;
            text-align: center;
        }
        .level-select {
            color: #fff;
            font-size: clamp(18px, 4vw, 32px);
            font-family: Arial, sans-serif;
            margin: 5vh 0;
            text-align: center;
        }
        .title-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .title-btn {
            background-color: #555;
            color: #fff;
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 10px 20px;
            font-size: clamp(14px, 2.5vw, 18px);
            touch-action: manipulation;
            user-select: none;
            cursor: pointer;
            min-width: 80px;
            text-align: center;
        }
        .title-btn:active {
            background-color: #777;
        }
        .cutscene-btn {
            position: absolute;
            bottom: calc(20vh + env(safe-area-inset-bottom));
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 15;
            min-width: 100px;
            padding: 12px 24px;
            font-size: clamp(16px, 3vw, 20px);
        }
        @media (max-width: 600px) {
            .controls {
                grid-template-columns: repeat(3, minmax(30px, 10vw));
                grid-template-rows: repeat(2, minmax(30px, 10vw));
                gap: 3px;
                right: calc(5px + env(safe-area-inset-right));
                bottom: calc(5px + env(safe-area-inset-bottom));
            }
            .toggle-btn, .reset-btn {
                width: minmax(80px, 18vw);
                height: 6vh;
                font-size: clamp(14px, 3vw, 16px);
                left: calc(5px + env(safe-area-inset-left));
            }
            .reset-btn { bottom: calc(80px + env(safe-area-inset-bottom)); }
            .control-btn {
                font-size: clamp(16px, 3.5vw, 20px);
            }
            .title-text {
                font-size: clamp(20px, 5vw, 36px);
            }
            .level-select {
                font-size: clamp(16px, 3.5vw, 24px);
            }
            .title-btn {
                font-size: clamp(12px, 2vw, 16px);
                padding: 8px 15px;
                min-width: 60px;
            }
            .cutscene-btn {
                bottom: calc(15vh + env(safe-area-inset-bottom));
                padding: 10px 20px;
                font-size: clamp(14px, 3.5vw, 18px);
                min-width: 80px;
            }
        }
        @media (orientation: landscape) and (max-height: 500px) {
            .controls {
                grid-template-columns: repeat(3, minmax(25px, 7vw));
                grid-template-rows: repeat(2, minmax(25px, 7vw));
                gap: 2px;
            }
            .toggle-btn, .reset-btn {
                width: minmax(70px, 14vw);
                height: 6vh;
                font-size: clamp(12px, 2.5vw, 14px);
            }
            .reset-btn { bottom: calc(70px + env(safe-area-inset-bottom)); }
            .title-text {
                font-size: clamp(18px, 4vw, 32px);
                margin-top: 3vh;
            }
            .level-select {
                font-size: clamp(14px, 3vw, 20px);
                margin: 3vh 0;
            }
            .title-btn {
                font-size: clamp(10px, 1.8vw, 14px);
                padding: 6px 12px;
                min-width: 50px;
            }
            .cutscene-btn {
                bottom: calc(10vh + env(safe-area-inset-bottom));
                padding: 8px 16px;
                font-size: clamp(12px, 2.5vw, 16px);
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <div class="title-screen">
        <div class="title-text">SWSS 2: Recrudescence</div>
        <div class="level-select" id="level-select">Level 1 - Temple</div>
        <div class="title-buttons">
            <div class="title-btn" id="prev-level-btn">Previous</div>
            <div class="title-btn" id="play-btn">Play</div>
            <div class="title-btn" id="next-level-btn">Next</div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <div class="controls">
        <div class="empty"></div>
        <div class="control-btn" id="up-btn">↑</div>
        <div class="control-btn" id="undo-btn">↶</div>
        <div class="control-btn" id="left-btn">←</div>
        <div class="control-btn" id="down-btn">↓</div>
        <div class="control-btn" id="right-btn">→</div>
    </div>
    <div class="toggle-btn" id="toggle-btn">Jump1</div>
    <div class="reset-btn" id="reset-btn">Menu</div>
    <div class="title-btn cutscene-btn" id="cutscene-next-btn">Next</div>
<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const titleScreen = document.querySelector('.title-screen');
    const levelSelectDisplay = document.getElementById('level-select');
    const playBtn = document.getElementById('play-btn');
    const nextLevelBtn = document.getElementById('next-level-btn');
    const prevLevelBtn = document.getElementById('prev-level-btn');
    const resetBtn = document.getElementById('reset-btn');
    const cutsceneNextBtn = document.getElementById('cutscene-next-btn');

    const virtualWidth = 1600;
    const virtualHeight = 900;
    let scale = 1;

    const gridWidth = 16;
    const gridHeight = 8;
    const cellWidth = virtualWidth / gridWidth;
    const cellHeight = (virtualHeight * (gridHeight / 9)) / gridHeight;
    const statusBarHeight = virtualHeight / 9;

    const speakerImage = new Image();
    speakerImage.src = 'download.jpg'; // Replace with your .png file path   

    let selectedLevel = 1;
    let currentLevel = 1;
    let levelName = "Level 1 - Temple";
    let hasWon = false;

    let isInputActive = false;
    let movementMode = 'jump1';
    let isPlayerDead = false;
    let movement_lock = false;
    let grid = [];
    let can_be_killed = 1;
    let moveCount = 0;

    let slipping = false;
    let slipDir = { dx: 0, dy: 0 };

    let totalFloorTiles = 0;
    let particles = [];
    let gameStateHistory = []; // For undo feature

    let isCutscene = false;
    let fullText = '';
    let currentText = '';
    let currentTextIndex = 0;
    let typingSpeed = 50; // ms per letter
    let lastTypeTime = 0;

    const levels = {
        1: { type: "cutscene", name: "Enter: Kuyuti Kawa II :sparkles:", text: [
            "Tra-la-la...! Tra-la-la-la...!",
            "Ugyuuu... I never did master the splorty.",
            "But I won't give up! Here I go!",
            "Uh... Uuuwa-wa-wa-wa-wa-wa...!!"
        ]},
        2: { type: "level", name: "Level 1 - Temple", layout: [
            "################",
            "#..>....~~......",
            "#..####..####..#",
            "#..#..#..#..#..#",
            "#..####..####..#",
            "#....~~........#",
            "#......P.....<.#",
            "################"
        ]},
        3: { type: "level", name: "Level 2 - Cave", layout: [
            "################",
            "#..#....~~...P.#",
            "#..#....~~...<.#",
            "#..###.####..#.#",
            "#....#.#..#..#v#",
            "#....#....#....#",
            "#.>..##.###....#",
            "################"
        ]},
        4: { type: "cutscene", name: "Punished Kuyuti", text: [
            "I'll never trust those green squares that move around!!",
            "Uh-uh. That’s cute or whatever.",
            "Uu... Ugyuuu... I can't let them thwarty my splorty...",
            "And on God I don’t chase the splorty. I live (ikiteiru) within the splorty nation.",
            "...PERIODT!"
        ]},
        5: { type: "level", name: "Level 3 - Forest", layout: [
            "################",
            "#...P..........#",
            "#..#.#.....#...#",
            "#..###.....#...#",
            "#..#....S......#",
            "#..#..A....#...#",
            "#..#....~~.....#",
            "################"
        ]},
        6: { type: "level", name: "Level 4 - Trial", layout: [
            "################",
            "#....3....2....#",
            "#..####..####..#",
            "#..#..#..#..#..#",
            "#..####..1....P#",
            "#....0....~~...#",
            "#......#..#....#",
            "################"
        ]},
        7: { type: "cutscene", name: "Intrinsic Kuyuti Mindset", text: [
            "I was in the middle of a nap, like, rude.",
            "Is you serious?",
            "Imma need you to stop acting brand new.",
            "Let me say that... (pause for emphasis...) one-mo'-'gain.",
            "I'll splorty 'til the evening. My quest... is to claim the tiles. Iku zo!",
        ]},
    };

    const maxLevel = Object.keys(levels).length;

    function updateLevelSelectDisplay() {
        const level = levels[selectedLevel];
        if (level.type === 'cutscene') {
            levelSelectDisplay.textContent = `${level.name}`;
        } else {
            levelSelectDisplay.textContent = `${level.name}`;
        }
    }

    function createParticles(x, y) {
        const particleCount = 12;
        const tileLeft = x * cellWidth;
        const tileRight = (x + 1) * cellWidth;
        const tileTop = statusBarHeight + y * cellHeight;
        const tileBottom = statusBarHeight + (y + 1) * cellHeight;
        const inset = 0.1;

        const spawnPoints = [
            { px: tileLeft + inset * cellWidth, py: tileTop + inset * cellHeight, vx: -50, vy: -50 },
            { px: tileRight - inset * cellWidth, py: tileTop + inset * cellHeight, vx: 50, vy: -50 },
            { px: tileLeft + inset * cellWidth, py: tileBottom - inset * cellHeight, vx: -50, vy: 50 },
            { px: tileRight - inset * cellWidth, py: tileBottom - inset * cellHeight, vx: 50, vy: 50 },
            { px: tileLeft + cellWidth / 2, py: tileTop + inset * cellHeight, vx: 0, vy: -75 },
            { px: tileRight - inset * cellWidth, py: tileTop + cellHeight / 2, vx: 75, vy: 0 },
            { px: tileLeft + cellWidth / 2, py: tileBottom - inset * cellHeight, vx: 0, vy: 75 },
            { px: tileLeft + inset * cellWidth, py: tileTop + cellHeight / 2, vx: -75, vy: 0 },
            { px: tileLeft + inset * cellWidth, py: tileTop + cellHeight / 3, vx: -60, vy: -30 },
            { px: tileRight - inset * cellWidth, py: tileTop + 2 * cellHeight / 3, vx: 60, vy: 30 },
            { px: tileLeft + cellWidth / 3, py: tileTop + inset * cellHeight, vx: -30, vy: -60 },
            { px: tileRight - cellWidth / 3, py: tileBottom - inset * cellHeight, vx: 30, vy: 60 }
        ];

        for (let i = 0; i < particleCount; i++) {
            const sp = spawnPoints[i % spawnPoints.length];
            particles.push({
                x: sp.px,
                y: sp.py,
                vx: sp.vx + (Math.random() - 0.5) * 20,
                vy: sp.vy + (Math.random() - 0.5) * 20,
                size: 20,
                moveTime: 0.5,
                isStatic: false,
                rotation: Math.random() * 360,
                rotationSpeed: (Math.random() - 0.5) * 180
            });
        }

        for (let i = 0; i < (particleCount * 2); i++) {
            const sp = spawnPoints[i % spawnPoints.length];
            particles.push({
                x: sp.px,
                y: sp.py,
                vx: sp.vx + (Math.random() - 0.5) * 200,
                vy: sp.vy + (Math.random() - 0.5) * 200,
                size: 10,
                moveTime: 0.25,
                isStatic: false,
                rotation: Math.random() * 360,
                rotationSpeed: (Math.random() - 0.5) * 360
            });
        }
    }

    function updateParticles(deltaTime) {
        particles.forEach(p => {
            if (!p.isStatic) {
                p.x += p.vx * deltaTime;
                p.y += p.vy * deltaTime;
                p.moveTime -= deltaTime;

                const gridX = Math.floor(p.x / cellWidth);
                const gridY = Math.floor((p.y - statusBarHeight) / cellHeight);

                if (gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight) {
                    const cell = grid.find(c => c.x === gridX && c.y === gridY);
                    if (cell && (cell.state === 'wall' || cell.state === 'pit')) {
                        p.isStatic = true;
                    }
                } else {
                    p.isStatic = true;
                }

                if (p.moveTime <= 0) {
                    p.isStatic = true;
                }
            }
        });
    }

    function drawCutsceneText() {
        ctx.fillStyle = '#F5F5F5';
        ctx.fillRect(0, 0, virtualWidth, statusBarHeight);
        ctx.fillStyle = '#666666';
        ctx.font = `${statusBarHeight * 0.5}px Arial`;
        ctx.textBaseline = 'middle';

        ctx.textAlign = 'left';
        ctx.fillText(levels[currentLevel].name || 'Cutscene', 10, statusBarHeight / 2);

        ctx.textAlign = 'right';
        ctx.fillText('Press Next to continue', virtualWidth - 10, statusBarHeight / 2);

        const imageHeight = (virtualHeight - statusBarHeight) / 2 - 50;
        if (speakerImage.complete && speakerImage.naturalWidth && speakerImage.naturalHeight) {
            const aspectRatio = speakerImage.naturalWidth / speakerImage.naturalHeight;
            let destWidth = imageHeight * aspectRatio;
            let destHeight = imageHeight;
            let destX = 50;

            const maxWidth = virtualWidth - 100;
            if (destWidth > maxWidth) {
                destWidth = maxWidth;
                destHeight = maxWidth / aspectRatio;
            }

            destX = (virtualWidth - destWidth) / 2;
            ctx.drawImage(speakerImage, destX, statusBarHeight, destWidth, destHeight);
        } else {
            ctx.fillStyle = '#555';
            ctx.fillRect(50, statusBarHeight, virtualWidth - 100, imageHeight);
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 4;
            ctx.strokeRect(50, statusBarHeight, virtualWidth - 100, imageHeight);
        }

        ctx.fillStyle = '#333';
        const bgPadding = 50;
        const bgWidth = virtualWidth - 2 * bgPadding;
        const bgHeight = (virtualHeight - statusBarHeight) / 2;
        const bgX = bgPadding;
        const bgY = statusBarHeight + imageHeight;
        ctx.fillRect(bgX, bgY, bgWidth, bgHeight);

        ctx.strokeStyle = '#666';
        ctx.lineWidth = 4;
        ctx.strokeRect(bgX, bgY, bgWidth, bgHeight);

        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';
        const maxFontSize = Math.min(virtualWidth, virtualHeight) * 0.05;
        const minFontSize = Math.min(virtualWidth, virtualHeight) * 0.03;
        const fontSize = Math.max(minFontSize, Math.min(maxFontSize, statusBarHeight * 1.0));
        ctx.font = `${fontSize}px Arial, sans-serif`;

        const lines = currentText.split('\n');
        const lineHeight = fontSize * 1.2;
        const maxTextWidth = bgWidth - 40;
        const startY = bgY + 40;
        const maxLines = Math.floor(bgHeight / lineHeight) - 1;

        const wrappedLines = [];
        lines.forEach(line => {
            if (ctx.measureText(line).width <= maxTextWidth) {
                wrappedLines.push(line);
            } else {
                const words = line.split(' ');
                let currentLine = '';
                words.forEach(word => {
                    const testLine = currentLine ? currentLine + ' ' + word : word;
                    if (ctx.measureText(testLine).width <= maxTextWidth) {
                        currentLine = testLine;
                    } else {
                        if (currentLine) wrappedLines.push(currentLine);
                        currentLine = word;
                    }
                });
                if (currentLine) wrappedLines.push(currentLine);
            }
        });

        for (let i = 0; i < Math.min(wrappedLines.length, maxLines); i++) {
            const y = startY + i * lineHeight;
            if (y < bgY + bgHeight - 20) {
                ctx.fillText(wrappedLines[i], bgX + 20, y);
            }
        }

        if (currentTextIndex < fullText.length) {
            ctx.fillStyle = '#888';
            ctx.font = `${fontSize * 0.8}px Arial, sans-serif`;
            ctx.fillText('...', bgX + 20, startY + maxLines * lineHeight + 10);
        }
    }

    function draw() {
        ctx.save();
        ctx.scale(scale, scale);
        ctx.clearRect(0, 0, virtualWidth, virtualHeight);

        if (isCutscene) {
            drawCutsceneText();
        } else {
            const claimedTiles = grid.filter(cell => cell.isClaimed || cell.state === 'player').length;

            hasWon = grid.every(cell => 
                cell.state === 'wall' || 
                cell.state === 'pit' || 
                cell.isClaimed || 
                cell.state === 'player' || 
                cell.state.startsWith('timer-')
            );

            ctx.fillStyle = '#F5F5F5';
            ctx.fillRect(0, 0, virtualWidth, statusBarHeight);
            ctx.font = `${statusBarHeight * 0.5}px Arial`;
            ctx.textBaseline = 'middle';

            ctx.textAlign = 'left';
            ctx.fillStyle = '#666666';
            ctx.fillText(levelName, 10, statusBarHeight / 2);

            ctx.textAlign = 'right';
            if (hasWon) {
                ctx.fillStyle = '#00FF00';
                ctx.fillText('You Won! Press Space or Tap to Continue', virtualWidth - 10, statusBarHeight / 2);
            } else if (isPlayerDead) {
                ctx.fillStyle = '#FF0000';
                ctx.fillText('Game Over - Press Reset', virtualWidth - 10, statusBarHeight / 2);
            } else {
                ctx.fillStyle = '#666666';
                ctx.fillText(`${movementMode} - Moves: ${moveCount} - Claimed: ${claimedTiles}/${totalFloorTiles}`, virtualWidth - 10, statusBarHeight / 2);
            }

            grid.forEach(cell => {
                if (cell.state === 'floor') ctx.fillStyle = '#8B8B83';
                else if (cell.state === 'claimed') ctx.fillStyle = '#D3D3D3';
                else if (cell.state === 'wall') ctx.fillStyle = '#5C5C5A';
                else if (cell.state === 'pit') ctx.fillStyle = '#000000';
                else if (cell.state === 'timer-3') ctx.fillStyle = '#6B6B6B';
                else if (cell.state === 'timer-2') ctx.fillStyle = '#6B6B6B';
                else if (cell.state === 'timer-1') ctx.fillStyle = '#8B8B83';
                else if (cell.state === 'timer-0') ctx.fillStyle = '#000000';
                else if (cell.state === 'player') ctx.fillStyle = isPlayerDead ? '#FF0000' : hasWon ? '#00FF00' : '#00f';
                else if (cell.state.startsWith('enemy-') || cell.state.startsWith('killer-enemy-')) ctx.fillStyle = '#00FF00';
                ctx.fillRect(cell.x * cellWidth, statusBarHeight + cell.y * cellHeight, cellWidth, cellHeight);

                if (cell.state.startsWith('timer-')) {
                    const num = cell.state.split('-')[1];
                    let color = num === '1' ? '#FF0000' : '#DDDDDD';
                    ctx.fillStyle = color;
                    ctx.font = `${cellHeight * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(num, (cell.x + 0.5) * cellWidth, statusBarHeight + (cell.y + 0.5) * cellHeight);
                } else if (cell.state.startsWith('enemy-') || cell.state.startsWith('killer-enemy-')) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${cellHeight * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    let symbol;
                    switch (cell.state) {
                        case 'enemy-right': symbol = '>'; break;
                        case 'enemy-left': symbol = '<'; break;
                        case 'enemy-up': symbol = '^'; break;
                        case 'enemy-down': symbol = 'v'; break;
                        case 'killer-enemy-right': symbol = '>>'; break;
                        case 'killer-enemy-left': symbol = '<<'; break;
                        case 'killer-enemy-up': symbol = '^^'; break;
                        case 'killer-enemy-down': symbol = 'vv'; break;
                    }
                    ctx.fillText(symbol, (cell.x + 0.5) * cellWidth, statusBarHeight + (cell.y + 0.5) * cellHeight);
                }

                if (cell.state === 'player') {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.font = `${cellHeight * 0.8}px "Segoe UI Emoji", Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerX = (cell.x + 0.5) * cellWidth;
                    const centerY = statusBarHeight + (cell.y + 0.5) * cellHeight;
                    if (isPlayerDead) {
                        ctx.save();
                        ctx.translate(centerX, centerY);
                        ctx.rotate(Math.PI);
                        ctx.fillText('🧙‍♀️', 0, 0);
                        ctx.restore();
                    } else {
                        ctx.fillText('🧙‍♀️', centerX, centerY);
                    }
                }
            });
        }

        particles.forEach(p => {
            ctx.fillStyle = p.isStatic ? 'rgba(255, 0, 0, 0.8)' : `rgba(255, 0, 0, ${1 - p.moveTime / 0.5})`;
            ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
        });

        ctx.restore();

        resetBtn.textContent = isPlayerDead ? 'Reset' : 'Menu';
    }

    let lastTime = 0;
    function animate(timestamp) {
        if (lastTime === 0) lastTime = timestamp;
        const deltaTime = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        if (isCutscene) {
            const now = timestamp;
            if (now - lastTypeTime > typingSpeed && currentTextIndex < fullText.length) {
                currentText += fullText[currentTextIndex];
                currentTextIndex++;
                lastTypeTime = now;
            }
            if (currentTextIndex >= fullText.length) {
                cutsceneNextBtn.style.display = 'block';
            }
        }

        updateParticles(deltaTime);
        draw();

        requestAnimationFrame(animate);
    }

    function cycleTimers() {
        grid.forEach(cell => {
            let timerState = cell.state.startsWith('timer-') ? cell.state : (cell.underlyingState && cell.underlyingState.startsWith('timer-') ? cell.underlyingState : null);
            if (timerState) {
                let newTimerState;
                if (timerState === 'timer-3') newTimerState = 'timer-2';
                else if (timerState === 'timer-2') newTimerState = 'timer-1';
                else if (timerState === 'timer-1') newTimerState = 'timer-0';
                else if (timerState === 'timer-0') newTimerState = 'timer-3';
                
                if (cell.state.startsWith('timer-')) {
                    cell.state = newTimerState;
                } else if (cell.state === 'player') {
                    cell.underlyingState = newTimerState;
                }
            }
        });
    }

    function initializeGrid(level) {
        grid = [];
        const staticLevel = levels[level];
        for (let y = 0; y < gridHeight; y++) {
            for (let x = 0; x < gridWidth; x++) {
                let char = staticLevel.layout[y][x];
                let state = 'floor';
                let isClaimed = false;
                let underlyingState = null;
                if (char === '#') state = 'wall';
                else if (char === '.') state = 'floor';
                else if (char === 'P') state = 'player';
                else if (char === '~') state = 'pit';
                else if (char === '>') state = 'enemy-right';
                else if (char === '<') state = 'enemy-left';
                else if (char === '^') state = 'enemy-up';
                else if (char === 'v') state = 'enemy-down';
                else if (char === 'D') state = 'killer-enemy-right';
                else if (char === 'A') state = 'killer-enemy-left';
                else if (char === 'W') state = 'killer-enemy-up';
                else if (char === 'S') state = 'killer-enemy-down';
                else if (char === '3') state = 'timer-3';
                else if (char === '2') state = 'timer-2';
                else if (char === '1') state = 'timer-1';
                else if (char === '0') state = 'timer-0';
                grid.push({ x, y, state, isClaimed, underlyingState });
            }
        }
        totalFloorTiles = grid.filter(cell => cell.state !== 'wall' && cell.state !== 'pit' && !cell.state.startsWith('timer-')).length;
        levelName = `${staticLevel.name}`;
        currentLevel = level;
        can_be_killed = 1;
        moveCount = 0;
        particles = [];
        gameStateHistory = [];
    }

    function startCutscene() {
        isCutscene = true;
        const scene = levels[selectedLevel];
        fullText = scene.text.join('\n');
        currentText = '';
        currentTextIndex = 0;
        lastTypeTime = 0;
        cutsceneNextBtn.style.display = 'none';
        particles = [];
        levelName = "Cutscene";
        gameStateHistory = [];
    }

    function proceedToNext() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        particles = [];
        moveCount = 0;
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
        gameStateHistory = [];

        selectedLevel++;
        if (selectedLevel > maxLevel) selectedLevel = 1;
        currentLevel = selectedLevel;

        const scene = levels[currentLevel];
        if (scene.type === 'cutscene') {
            document.querySelector('.controls').style.display = 'none';
            document.querySelector('.toggle-btn').style.display = 'none';
            document.querySelector('.reset-btn').style.display = 'none';
            startCutscene();
        } else {
            document.querySelector('.controls').style.display = 'grid';
            document.querySelector('.toggle-btn').style.display = 'flex';
            document.querySelector('.reset-btn').style.display = 'flex';
            initializeGrid(currentLevel);
            resetBtn.textContent = 'Menu';
        }
        isCutscene = scene.type === 'cutscene';
        cutsceneNextBtn.style.display = 'none';
        resizeCanvas();
        requestAnimationFrame(animate);
    }

    function setBodyHeight() {
        document.body.style.height = `${window.innerHeight}px`;
    }

    function resizeCanvas() {
        setBodyHeight();
        const aspect = virtualWidth / virtualHeight;
        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width / height > aspect) {
            canvas.height = height;
            canvas.width = height * aspect;
        } else {
            canvas.width = width;
            canvas.height = width / aspect;
        }

        scale = canvas.width / virtualWidth;
        draw();
    }

    function showTitleScreen() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
        particles = [];
        moveCount = 0;
        isCutscene = false;
        gameStateHistory = [];
        document.getElementById('toggle-btn').textContent = 'Jump1';
        titleScreen.style.display = 'flex';
        canvas.style.display = 'none';
        document.querySelector('.controls').style.display = 'none';
        document.querySelector('.toggle-btn').style.display = 'none';
        document.querySelector('.reset-btn').style.display = 'none';
        cutsceneNextBtn.style.display = 'none';
        updateLevelSelectDisplay();
    }

    function showScene() {
        titleScreen.style.display = 'none';
        canvas.style.display = 'block';
        const scene = levels[selectedLevel];
        if (scene.type === 'level') {
            document.querySelector('.controls').style.display = 'grid';
            document.querySelector('.toggle-btn').style.display = 'flex';
            document.querySelector('.reset-btn').style.display = 'flex';
            initializeGrid(selectedLevel);
            resetBtn.textContent = 'Menu';
            isCutscene = false;
        } else if (scene.type === 'cutscene') {
            document.querySelector('.controls').style.display = 'none';
            document.querySelector('.toggle-btn').style.display = 'none';
            document.querySelector('.reset-btn').style.display = 'none';
            startCutscene();
        }
        resizeCanvas();
        requestAnimationFrame(animate);
    }

    function findPlayer() {
        return grid.find(cell => cell.state === 'player');
    }

    function saveGameState() {
        gameStateHistory.push({
            grid: grid.map(cell => ({ ...cell })),
            moveCount,
            isPlayerDead,
            hasWon,
            movementMode,
            slipping,
            slipDir: { ...slipDir },
            particles: [...particles]
        });
        if (gameStateHistory.length > 10) gameStateHistory.shift(); // Limit to 10 states
    }

    function undoMove() {
        if (gameStateHistory.length === 0 || isCutscene || isPlayerDead || hasWon) return;
        const lastState = gameStateHistory.pop();
        grid = lastState.grid.map(cell => ({ ...cell }));
        moveCount = lastState.moveCount;
        isPlayerDead = lastState.isPlayerDead;
        hasWon = lastState.hasWon;
        movementMode = lastState.movementMode;
        slipping = lastState.slipping;
        slipDir = { ...lastState.slipDir };
        particles = [...lastState.particles];
        can_be_killed = 1;
        movement_lock = false;
        isInputActive = false;
        document.getElementById('toggle-btn').textContent = movementMode;
        draw();
    }

    function attemptMove(dx, dy, claimStart = true) {
        const player = findPlayer();
        if (!player) return false;
        const newX = player.x + dx;
        const newY = player.y + dy;
        if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) return false;
        const target = grid.find(c => c.x === newX && c.y === newY);

        if (target.state === 'wall') return false;

        if (claimStart) {
            if (player.underlyingState && player.underlyingState.startsWith('timer-')) {
                player.state = player.underlyingState;
                player.underlyingState = null;
            } else {
                player.isClaimed = true;
                player.state = 'claimed';
            }
        }

        if (target.state === 'pit' || target.state === 'timer-0') {
            target.state = 'player';
            isPlayerDead = true;
            createParticles(newX, newY);
            draw();
            return false;
        } else if (target.state.startsWith('enemy-') || target.state.startsWith('killer-enemy-')) {
            return 'enemy';
        } else if (target.isClaimed) {
            if (target.state.startsWith('timer-')) {
                target.underlyingState = target.state;
            }
            target.state = 'player';
            draw();
            return 'slip';
        } else {
            if (target.state.startsWith('timer-')) {
                target.underlyingState = target.state;
            }
            target.state = 'player';
            draw();
            return true;
        }
    }

    function moveEnemies() {
        const enemies = grid.filter(cell => 
            cell.state === 'enemy-right' || cell.state === 'enemy-left' || cell.state === 'enemy-up' || cell.state === 'enemy-down' ||
            cell.state === 'killer-enemy-right' || cell.state === 'killer-enemy-left' || cell.state === 'killer-enemy-up' || cell.state === 'killer-enemy-down'
        );
        const enemyUpdates = [];
        const swaps = new Map();

        enemies.forEach(enemy => {
            const currentState = enemy.state;
            let dx = 0, dy = 0;
            let newState = currentState;
            let moveTo = null;

            if (currentState === 'enemy-right' || currentState === 'killer-enemy-right') dx = 1;
            else if (currentState === 'enemy-left' || currentState === 'killer-enemy-left') dx = -1;
            else if (currentState === 'enemy-up' || currentState === 'killer-enemy-up') dy = -1;
            else if (currentState === 'enemy-down' || currentState === 'killer-enemy-down') dy = 1;

            let nextX = enemy.x + dx;
            let nextY = enemy.y + dy;

            if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                const nextCell = grid.find(c => c.x === nextX && c.y === nextY);
                if (nextCell && nextCell.state !== 'wall' && nextCell.state !== 'pit' && nextCell.state !== 'timer-0') {
                    const targetEnemy = enemies.find(e => e.x === nextX && e.y === nextY);
                    if (targetEnemy) {
                        let targetDx = 0, targetDy = 0;
                        if (targetEnemy.state === 'enemy-right' || targetEnemy.state === 'killer-enemy-right') targetDx = 1;
                        else if (targetEnemy.state === 'enemy-left' || targetEnemy.state === 'killer-enemy-left') targetDx = -1;
                        else if (targetEnemy.state === 'enemy-up' || targetEnemy.state === 'killer-enemy-up') targetDy = -1;
                        else if (targetEnemy.state === 'enemy-down' || targetEnemy.state === 'killer-enemy-down') targetDy = 1;
                        if (targetEnemy.x + targetDx === enemy.x && targetEnemy.y + targetDy === enemy.y) {
                            const key = `${Math.min(enemy.x, nextX)},${Math.min(enemy.y, nextY)}-${Math.max(enemy.x, nextX)},${Math.max(enemy.y, nextY)}`;
                            if (!swaps.has(key)) {
                                swaps.set(key, [
                                    { enemy, target: { x: nextX, y: nextY }, newState: enemy.state },
                                    { enemy: targetEnemy, target: { x: enemy.x, y: enemy.y }, newState: targetEnemy.state }
                                ]);
                            }
                        } else {
                            if (currentState.endsWith('-right')) newState = currentState.replace('right', 'left');
                            else if (currentState.endsWith('-left')) newState = currentState.replace('left', 'right');
                            else if (currentState.endsWith('-up')) newState = currentState.replace('up', 'down');
                            else if (currentState.endsWith('-down')) newState = currentState.replace('down', 'up');
                        }
                    } else {
                        moveTo = { x: nextX, y: nextY };
                    }
                } else {
                    if (currentState.endsWith('-right')) newState = currentState.replace('right', 'left');
                    else if (currentState.endsWith('-left')) newState = currentState.replace('left', 'right');
                    else if (currentState.endsWith('-up')) newState = currentState.replace('up', 'down');
                    else if (currentState.endsWith('-down')) newState = currentState.replace('down', 'up');
                }
            } else {
                if (currentState.endsWith('-right')) newState = currentState.replace('right', 'left');
                else if (currentState.endsWith('-left')) newState = currentState.replace('left', 'right');
                else if (currentState.endsWith('-up')) newState = currentState.replace('up', 'down');
                else if (currentState.endsWith('-down')) newState = currentState.replace('down', 'up');
            }

            enemyUpdates.push({ enemy, newState, moveTo });
        });

        const landingPositions = new Map();
        enemyUpdates.forEach((update, index) => {
            if (swaps.has(`${update.enemy.x},${update.enemy.y}-${update.moveTo?.x},${update.moveTo?.y}`)) {
                return;
            }
            if (update.moveTo) {
                const key = `${update.moveTo.x},${update.moveTo.y}`;
                if (!landingPositions.has(key)) landingPositions.set(key, []);
                landingPositions.get(key).push({ update, index });
            }
        });

        landingPositions.forEach((targeters, key) => {
            if (targeters.length > 1) {
                targeters.forEach(({ update }) => {
                    const currentState = update.enemy.state;
                    if (currentState.endsWith('-right')) update.newState = currentState.replace('right', 'left');
                    else if (currentState.endsWith('-left')) update.newState = currentState.replace('left', 'right');
                    else if (currentState.endsWith('-up')) update.newState = currentState.replace('up', 'down');
                    else if (currentState.endsWith('-down')) update.newState = currentState.replace('down', 'up');
                    update.moveTo = null;
                });
            }
        });

        enemyUpdates.forEach((update, index) => {
            if (!update.moveTo && update.newState !== update.enemy.state && !swaps.has(`*-${update.enemy.x},${update.enemy.y}`)) {
                let dx = 0, dy = 0;
                if (update.newState.endsWith('-right')) dx = 1;
                else if (update.newState.endsWith('-left')) dx = -1;
                else if (update.newState.endsWith('-up')) dy = -1;
                else if (update.newState.endsWith('-down')) dy = 1;

                const nextX = update.enemy.x + dx;
                const nextY = update.enemy.y + dy;
                if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
                    const newCell = grid.find(c => c.x === nextX && c.y === nextY);
                    const key = `${nextX},${nextY}`;
                    const otherTargeters = landingPositions.get(key)?.filter(t => t.index !== index) || [];
                    if (newCell && newCell.state !== 'wall' && newCell.state !== 'pit' && newCell.state !== 'timer-0' && otherTargeters.length === 0 && !swaps.has(`*-${nextX},${nextY}`)) {
                        update.moveTo = { x: nextX, y: nextY };
                        landingPositions.set(key, [{ update, index }]);
                    }
                }
            }
        });

        swaps.forEach(swap => {
            const swapUpdates = swap.map(({ enemy, target, newState }) => ({
                enemy,
                target,
                newState,
                isClaimed: enemy.isClaimed
            }));
            swapUpdates.forEach(({ enemy, isClaimed }) => {
                enemy.state = isClaimed ? 'claimed' : 'floor';
            });
            swapUpdates.forEach(({ enemy, target, newState }) => {
                const targetCell = grid.find(c => c.x === target.x && c.y === target.y);
                if (targetCell.state === 'player') {
                    isPlayerDead = true;
                    createParticles(target.x, target.y);
                    enemy.state = isClaimed ? 'claimed' : 'floor';
                    targetCell.state = 'player';
                } else {
                    targetCell.state = newState;
                }
            });
        });

        enemyUpdates.forEach(({ enemy, newState, moveTo }) => {
            const swapKey = [...swaps.keys()].find(key => key.includes(`${enemy.x},${enemy.y}`));
            if (swapKey) return;

            if (moveTo) {
                const targetCell = grid.find(c => c.x === moveTo.x && c.y === moveTo.y);
                if (targetCell.state === 'player') {
                    isPlayerDead = true;
                    createParticles(moveTo.x, moveTo.y);
                    targetCell.state = 'player';
                    enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                } else {
                    enemy.state = enemy.isClaimed ? 'claimed' : 'floor';
                    targetCell.state = newState;
                }
            } else {
                enemy.state = newState;
            }
        });

        draw();
    }

    function slipStep() {
        if (!slipping) return;

        const player = findPlayer();
        if (!player) return;

        if (isPlayerDead) {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
            draw();
            return;
        }

        const dx = slipDir.dx;
        const dy = slipDir.dy;
        const newX = player.x + dx;
        const newY = player.y + dy;
        const target = grid.find(c => c.x === newX && c.y === newY);

        let result = attemptMove(dx, dy);

        if (result === 'enemy') {
            moveEnemies();
            if (target.state.startsWith('enemy-') || target.state.startsWith('killer-enemy-')) {
                target.state = 'player';
                isPlayerDead = true;
                createParticles(player.x, player.y);
                result = false;
            } else {
                if (target.state.startsWith('timer-')) {
                    target.underlyingState = target.state;
                }
                target.state = 'player';
                result = target.isClaimed ? 'slip' : true;
            }
            draw();
        } else {
            if (result === false && !isPlayerDead) {
                slipping = false;
                movement_lock = false;
                can_be_killed = 1;
                return;
            }
            moveEnemies();
        }

        if (result === 'slip' && !isPlayerDead) {
            setTimeout(slipStep, 100);
        } else {
            slipping = false;
            movement_lock = false;
            can_be_killed = 1;
        }
    }

    function movePlayer(dx, dy) {
        if (isPlayerDead || movement_lock || hasWon || !can_be_killed) {
            isInputActive = false;
            return;
        }

        saveGameState();
        moveCount++;
        cycleTimers();

        const player = findPlayer();
        const jumpDistance = movementMode === 'jump1' ? 1 : 2;
        const oldX = player.x;
        const oldY = player.y;
        const newX = oldX + dx * jumpDistance;
        const newY = oldY + dy * jumpDistance;

        let validMove = true;
        if (newX < 0 || newX >= gridWidth || newY < 0 || newY >= gridHeight) validMove = false;
        else {
            const intendedTarget = grid.find(c => c.x === newX && c.y === newY);
            if (intendedTarget.state === 'wall') validMove = false;
        }

        const playerOldCell = player;
        let playerTargetCell;
        let result;

        if (!validMove) {
            playerTargetCell = playerOldCell;
            if (player.underlyingState === 'timer-0') {
                isPlayerDead = true;
                createParticles(player.x, player.y);
                playerOldCell.state = 'player';
                playerOldCell.underlyingState = 'timer-0';
                draw();
                can_be_killed = 1;
                movement_lock = false;
                isInputActive = false;
                return;
            }
            movement_lock = false;
            isInputActive = false;
            can_be_killed = 1;
            moveEnemies();
            draw();
            return;
        } else {
            playerTargetCell = grid.find(c => c.x === newX && c.y === newY);
        }

        const isPit = playerTargetCell.state === 'pit' || playerTargetCell.state === 'timer-0';
        let enemyThere = playerTargetCell.state.startsWith('enemy-') || playerTargetCell.state.startsWith('killer-enemy-');
        let isKiller = playerTargetCell.state.startsWith('killer-enemy-');
        let isFacingPlayer = false;
        let isFacingAway = false;
        let isBlocked = false;
        let willAttackPlayer = false;

        if (isKiller && enemyThere) {
            let facing_dx = 0, facing_dy = 0;
            switch (playerTargetCell.state) {
                case 'killer-enemy-right': facing_dx = 1; break;
                case 'killer-enemy-left': facing_dx = -1; break;
                case 'killer-enemy-up': facing_dy = -1; break;
                case 'killer-enemy-down': facing_dy = 1; break;
            }
            const toPlayer_dx = oldX - newX;
            const toPlayer_dy = oldY - newY;
            const sign_to_dx = Math.sign(toPlayer_dx);
            const sign_to_dy = Math.sign(toPlayer_dy);
            isFacingPlayer = facing_dx === sign_to_dx && facing_dy === sign_to_dy;
            isFacingAway = facing_dx === -sign_to_dx && facing_dy === -sign_to_dy;
            const enemyNextX = newX + facing_dx;
            const enemyNextY = newY + facing_dy;
            willAttackPlayer = enemyNextX === oldX && enemyNextY === oldY;
            const forwardX = newX + facing_dx;
            const forwardY = newY + facing_dy;
            if (forwardX < 0 || forwardX >= gridWidth || forwardY < 0 || forwardY >= gridHeight) {
                isBlocked = true;
            } else {
                const forwardCell = grid.find(c => c.x === forwardX && c.y === forwardY);
                isBlocked = forwardCell.state === 'wall' || forwardCell.state === 'pit';
            }
        }

        if (isKiller && isFacingPlayer && willAttackPlayer && jumpDistance === 1) {
            moveEnemies();
            isPlayerDead = true;
            createParticles(oldX, oldY);
            playerOldCell.state = 'player';
            draw();
            can_be_killed = 1;
            movement_lock = false;
            isInputActive = false;
            return;
        } else if (isKiller && isFacingAway && isBlocked && jumpDistance === 1) {
            moveEnemies();
            isPlayerDead = true;
            createParticles(oldX, oldY);
            playerOldCell.state = 'player';
            draw();
            can_be_killed = 1;
            movement_lock = false;
            isInputActive = false;
            return;
        } else {
            result = attemptMove(dx * jumpDistance, dy * jumpDistance);

            if (result === 'enemy') {
                moveEnemies();
                if (playerTargetCell.state.startsWith('enemy-') || playerTargetCell.state.startsWith('killer-enemy-')) {
                    playerTargetCell.state = 'player';
                    isPlayerDead = true;
                    createParticles(newX, newY);
                    result = false;
                } else {
                    if (playerTargetCell.state.startsWith('timer-')) {
                        playerTargetCell.underlyingState = playerTargetCell.state;
                    }
                    playerTargetCell.state = 'player';
                    result = playerTargetCell.isClaimed ? 'slip' : true;
                }
                draw();
            } else {
                if (result === false && !isPlayerDead) {
                    if (player.underlyingState === 'timer-0') {
                        isPlayerDead = true;
                        createParticles(player.x, player.y);
                        playerOldCell.state = 'player';
                        playerOldCell.underlyingState = 'timer-0';
                        draw();
                        can_be_killed = 1;
                        movement_lock = false;
                        isInputActive = false;
                        return;
                    }
                }
                moveEnemies();
            }
        }

        can_be_killed = 1;

        hasWon = grid.every(cell => 
            cell.state === 'wall' || 
            cell.state === 'pit' || 
            cell.isClaimed || 
            cell.state === 'player' || 
            cell.state.startsWith('timer-')
        );

        if (result === 'slip') {
            slipping = true;
            slipDir = { dx, dy };
            setTimeout(slipStep, 100);
        } else {
            movement_lock = false;
        }
        isInputActive = false;
    }

    function toggleMovementMode() {
        if (isPlayerDead || slipping || hasWon || !can_be_killed) return;
        movementMode = movementMode === 'jump1' ? 'jump2' : 'jump1';
        document.getElementById('toggle-btn').textContent = movementMode === 'jump1' ? 'Jump1' : 'Jump2';
        draw();
    }

    function resetLevel() {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        initializeGrid(currentLevel);
        moveCount = 0;
        particles = [];
        gameStateHistory = [];
        draw();
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
    }

    function changeLevel(direction) {
        isPlayerDead = false;
        hasWon = false;
        movementMode = 'jump1';
        document.getElementById('toggle-btn').textContent = 'Jump1';
        if (direction === 'next') {
            selectedLevel = selectedLevel === maxLevel ? 1 : selectedLevel + 1;
        } else {
            selectedLevel = selectedLevel === 1 ? maxLevel : selectedLevel - 1;
        }
        currentLevel = selectedLevel;
        particles = [];
        moveCount = 0;
        movement_lock = false;
        slipping = false;
        can_be_killed = 1;
        gameStateHistory = [];
        showTitleScreen();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    window.addEventListener('keydown', (e) => {
        if (isInputActive || slipping || !can_be_killed || titleScreen.style.display !== 'none') return;
        isInputActive = true;
        switch (e.key.toLowerCase()) {
            case 'arrowup': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, -1); break;
            case 'arrowdown': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(0, 1); break;
            case 'arrowleft': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(-1, 0); break;
            case 'arrowright': if (!isPlayerDead && !movement_lock && !hasWon) movePlayer(1, 0); break;
            case ' ': 
                if (hasWon) {
                    proceedToNext();
                } else if (isPlayerDead) resetLevel();
                else toggleMovementMode();
                break;
            case 'z': undoMove(); break;
            case 'q': changeLevel('previous'); break;
            case 'w': changeLevel('next'); break;
            case 'escape':
                showTitleScreen();
                break;
            case '0':
                if (!isPlayerDead && !hasWon) {
                    grid.forEach(cell => {
                        if (cell.state === 'floor') {
                            cell.state = 'claimed';
                            cell.isClaimed = true;
                        }
                    });
                    draw();
                }
                break;
        }
        isInputActive = false;
    });
    window.addEventListener('keyup', (e) => {
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
            movement_lock = false;
        }
        isInputActive = false;
    });

    const buttons = { 'up-btn': [0, -1], 'down-btn': [0, 1], 'left-btn': [-1, 0], 'right-btn': [1, 0], 'undo-btn': 'undo' };
    Object.keys(buttons).forEach(id => {
        const btn = document.getElementById(id);
        const action = buttons[id];
        function press(e) {
            e.preventDefault();
            e.stopPropagation();
            if (!isInputActive && !isPlayerDead && !movement_lock && !slipping && !hasWon && can_be_killed) {
                isInputActive = true;
                if (action === 'undo') {
                    undoMove();
                } else {
                    const [dx, dy] = action;
                    movePlayer(dx, dy);
                }
            }
        }
        function release(e) {
            e.preventDefault();
            e.stopPropagation();
            isInputActive = false;
            movement_lock = false;
        }
        btn.addEventListener('mousedown', press);
        btn.addEventListener('mouseup', release);
        btn.addEventListener('touchstart', press);
        btn.addEventListener('touchend', release);
    });

    const toggleBtn = document.getElementById('toggle-btn');
    toggleBtn.addEventListener('mousedown', e => {
        e.preventDefault();
        e.stopPropagation();
        if (!isInputActive && !isPlayerDead && !slipping && !hasWon && can_be_killed) {
            isInputActive = true;
            toggleMovementMode();
        }
    });
    toggleBtn.addEventListener('mouseup', e => {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    });
    toggleBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        e.stopPropagation();
        if (!isPlayerDead && !slipping && !hasWon && can_be_killed) {
            isInputActive = true;
            toggleMovementMode();
        }
    });
    toggleBtn.addEventListener('touchend', e => {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    });

    function resetOrMenu() {
        if (isPlayerDead) {
            resetLevel();
        } else {
            showTitleScreen();
        }
    }

    function resetPress(e) {
        e.preventDefault();
        e.stopPropagation();
        if (!isInputActive) {
            isInputActive = true;
            resetOrMenu();
            isInputActive = false;
        }
    }
    function resetRelease(e) {
        e.preventDefault();
        e.stopPropagation();
        isInputActive = false;
    }
    resetBtn.addEventListener('mousedown', resetPress);
    resetBtn.addEventListener('mouseup', resetRelease);
    resetBtn.addEventListener('touchstart', resetPress);
    resetBtn.addEventListener('touchend', resetRelease);

    playBtn.addEventListener('click', e => {
        e.preventDefault();
        showScene();
    });
    playBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        showScene();
    });

    nextLevelBtn.addEventListener('click', e => {
        e.preventDefault();
        changeLevel('next');
    });
    nextLevelBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        changeLevel('next');
    });

    prevLevelBtn.addEventListener('click', e => {
        e.preventDefault();
        changeLevel('previous');
    });
    prevLevelBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        changeLevel('previous');
    });

    document.body.addEventListener('touchstart', e => {
        e.preventDefault();
        if (hasWon && !isInputActive && titleScreen.style.display === 'none') {
            isInputActive = true;
            proceedToNext();
            isInputActive = false;
        }
    });

    cutsceneNextBtn.addEventListener('click', e => {
        e.preventDefault();
        proceedToNext();
    });
    cutsceneNextBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        proceedToNext();
    });

    updateLevelSelectDisplay();
    showTitleScreen();
</script>
</body>
</html>